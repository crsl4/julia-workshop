---
title: "Session 2: Data Tables and Arrow files"
jupyter: julia-1.8
---
Load packages to be used

```{julia}
#| code-fold: show
using Arrow             # Arrow storage and file format
using CategoricalArrays # compact, factor-like storage
using CSV               # CSV and related files
using Downloads         # file downloads
using DataFrames        # versatile tabular data format
using IntervalTrees     # interval trees implemented by BioJulia
using PyCall            # run Python within a Julia session
using RCall             # run R within a Julia session
using Tables            # row- or column-oriented data tables
using Tar               # tar archive utilities
```

## Objectives

- Use an example of computing interval overlaps to introduce Julia facilities for working with tabular data.
- Introduce the Arrow format for tabular data and demonstrate its use in Julia, Python/Pandas and R.
- Show a naive approach to computing overlaps
- Modify the approach to use [IntervalTrees.jl](https://github.com/BioJulia/IntervalTrees.jl)
- (Time permitting) An approach based on [cgranges](https://github.com/lh3/cgranges).

## Task and sample data

- [lh3/biofast](https://github.com/lh3/biofast) provides benchmark code for comparing programming languages on Bioinformatics tasks.
- One of these tasks, an [interval query](https://bedtools.readthedocs.io/en/latest/content/tools/coverage.html), takes two [.bed files](https://en.wikipedia.org/wiki/BED_(file_format)) to compare.
- One file contains a reference set of intervals, the other contains target intervals.
- For each target interval, determine which reference intervals overlap with it.
- In the benchmark both the number of reference intervals that overlap with a target and the proportion of the target covered by the overlap are computed.
- It appears that the calculation of the proportion of overlap assumes that the reference intervals are disjoint.  We will not make that assumption.

## Sample data

- The data sets for the benchmark are available as `biofast-data-v1.tar.gz` at [biofast-data-v1](https://github.com/lh3/biofast/releases/tag/biofast-data-v1)
- The following code chunks download the tarball, if necessary, and extract the two bedfiles to a directory `biofast-data-v1`, if necessary.
(Alternatively, you can just click on the link to the tarball in the github tag page and extract the files by hand.)

```{julia}
datadir = "biofast-data-v1"
tarball = "$datadir.tar.gz"
if !isfile(tarball)
  dataurl = joinpath(
    "https://github.com/lh3/biofast/releases/download",
    datadir,
    tarball,
  )
  Downloads.download(dataurl, tarball)
end
run(`ls -lh $tarball`);
```

- the `.tar.gz` file is about 0.5 GB. but most of that is the data for the FASTQ parsing test.

```{julia}
isdir(datadir) || mkdir(datadir)
bedfilenames = ["ex-anno.bed", "ex-rna.bed"]
if !all(nm -> isfile(joinpath(datadir, nm)), bedfilenames)
  tmpdir = Tar.extract(h -> endswith(h.path, ".bed"), `zcat ./$tarball`)
  for nm in bedfilenames
    mv(joinpath(tmpdir, datadir, nm), datadir)
  end
end
run(`ls -lh $datadir`);
```

::: {.callout-note}
Because of the way Quarto documents are rendered, this listing may contain `.arrow` files that are generated later in this document.
:::

## Initial processing

- The `.bed` files, in this case, are simple tab-separated-value files.
- Each of the language implementations in the benchmark contains code to parse lines of the `.bed` files producing a `String` and two `Int32` values.
- Furthermore the results of these benchmarks are written out as very large text files.  I don't plan to read a several-million-line text file to check if a program is working properly.
- Why go through this parsing of text files to create a numeric representation in each language?
- Writing code to parse a CSV or TSV file is tedious and error prone.
- But skilled people have put a lot of work into creating packages to do just that.
- More importantly they have tested, debugged, and documented their packages.
- Within the `CSV` package, the `CSV.read` function reads and parses a file and converts it to a type specified by the second argument.
- As is common for such functions, there are many, many optional named arguments
- We read `ex-anno.bed` and create a `DataFrame` as

```{julia}
annodf = CSV.read(
  "./biofast-data-v1/ex-anno.bed",
  DataFrame;
  delim='\t',
  types=[String, Int32, Int32],
  header=["chromo", "start", "stop"],
)
```

::: {.callout-note}
- Redundant commas are allowed at the end of the list of arguments before the `)` in a function call.
- Positional arguments must come before named arguments. Optionally, the comma after the last positional argument can be replace by a semicolon as shown above.
:::

- It turns out that both of the `.bed` files contain many duplicate rows. Use `unique!` to eliminate the duplicates.
- As row order is not important, we also `sort!` the `DataFrame` which has the effect of sorting the intervals within a chromosome by `start` position.
- Before sorting I will change strings like `"chr1"` to `"chr01"` so that sorting the strings also orders by chromosome number.
- We generate a vector of pairs of strings for replacement and "splat" them into a call to `replace`

```{julia}
replacements =  ["chr$i" => "chr0$i" for i in 1:9]
```

```{julia}
replace!(annodf.chromo, replacements...)
sort!(unique!(annodf))
annodf.chromo = categorical(annodf.chromo; ordered=true)
annodf
```

## Arrow file format

- The [Arrow project](https://arrow.apache.org) defines a memory and file format for storing and manipulating column-oriented, static, tables (i.e. like data frames in R, Python/Pandas, and Julia)
- When writing to a file either 'lz4' or 'zstd' compression can be used.
- Metadata on the names and types of columns is automatically stored.  Additional column or table metadata can be specified.

```{julia}
Arrow.write(
  "./biofast-data-v1/ex-anno.arrow",
  annodf;
  compress=:lz4,
  metadata=[
    "url" =>
    "https://github.com/lh3/biofast/releases/tag/biofast-data-v1",
  ],
)
```

::: {.callout-note}
In the call to `Arrow.write` the positional arguments and the named arguments are separated with `;` rather than `,`.
This is optional in these calls.
However, this convention can be used to indicate a named argument value is the same name as an object in an active namespace.
:::

```{julia}
rnaarrownm = let
  bednm = "./biofast-data-v1/ex-rna.bed"
  header = [:chromo, :start, :stop]
  delim = '\t'
  types = [String, Int32, Int32]
  rnadf = CSV.read(bednm, DataFrame; header, delim, types)
  replace!(rnadf.chromo, replacements...)
  sort!(unique!(rnadf))
  rnadf.chromo = categorical(rnadf.chromo; ordered=true)
  compress = :lz4
  metadata = [
    "url" => 
    "https://github.com/lh3/biofast/releases/tag/biofast-data-v1",
  ]
  Arrow.write(
    string(first(splitext(bednm)), ".arrow"),
    rnadf;
    compress,
    metadata,
  )
end
```

## Reading Arrow files in Julia

```{julia}
annotbl = Arrow.Table("./biofast-data-v1/ex-anno.arrow")
```

- Although the schema describes the `chromo` column as `String`s the values are dictionary encoded such that each value is represented by one byte.

```{julia}
typeof(annotbl.chromo)
```

```{julia}
rnatbl = Arrow.Table(rnaarrownm)
```

- We can use operations like split-apply-combine on these tables to summarize properties

```{julia}
innerjoin(
  combine(groupby(DataFrame(rnatbl), :chromo), nrow => :nrna),
  combine(groupby(DataFrame(annotbl), :chromo), nrow => :nanno);
  on=:chromo,
)  
```

## Reading Arrow files in Python

- In Python (and in R) the Arrow file format is confounded with an earlier file format called Feather and referred to as `Feather V2`.
- The `pyarrow` package includes `pyarrow.feather`.  Its use in a Python session looks like

```python
>>> import pyarrow.feather as fea
>>> fea.read_table('./biofast-data-v1/ex-rna.arrow')
pyarrow.Table
chromo: dictionary<values=string, indices=int8, ordered=0> not null
start: int32 not null
stop: int32 not null
----
chromo: [  -- dictionary:
["chr01","chr02","chr03","chr04","chr05",...,"chr20","chr21","chr22","chrX","chrY"]  -- indices:
[0,0,0,0,0,...,23,23,23,23,23]]
start: [[14354,14359,14361,14361,14366,...,18992169,18992297,24362035,24362037,25307904]]
stop: [[24892,24855,14672,16878,24894,...,18992298,18992676,24362135,24362201,25308109]]
>>> fea.read_feather('./biofast-data-v1/ex-rna.arrow')
        chromo     start      stop
0        chr01     14354     24892
1        chr01     14359     24855
2        chr01     14361     14672
3        chr01     14361     16878
4        chr01     14366     24894
...        ...       ...       ...
4685075   chrY  18992169  18992298
4685076   chrY  18992297  18992676
4685077   chrY  24362035  24362135
4685078   chrY  24362037  24362201
4685079   chrY  25307904  25308109

[4685080 rows x 3 columns]
```
- `read_table` returns a `Table` object, `read_feather` returns a Pandas dataframe.

- The `PyCall` package for `Julia` starts a Python process and allows communication with it, including data transfer.
- I use this instead of the Python REPL when working with both Julia and Python

```{julia}
fea = pyimport("pyarrow.feather")
fea.read_table(rnaarrownm)
```

- Notice that the `chromo` column has been converted from strings to a dictionary encoding of the unique values of the strings and 8-bit integer indices into this dictionary.

## Reading Arrow files in R

- In R the `arrow::read_feather` function returns a tibble.  In an R session it looks like

```r
> library(tibble)
> arrow::read_feather("./biofast-data-v1/ex-rna.arrow")
# A tibble: 4,685,080 × 3
   chromo start  stop
   <fct>  <int> <int>
 1 chr01  14354 24892
 2 chr01  14359 24855
 3 chr01  14361 14672
 4 chr01  14361 16878
 5 chr01  14366 24894
 6 chr01  14370 14989
 7 chr01  14396 24894
 8 chr01  14397 17733
 9 chr01  14398 24894
10 chr01  14399 15977
# … with 4,685,070 more rows
```

- The `RCall` package in Julia allows for running an R process within a Julia session

```{julia}
R"""
library(tibble)
glimpse(rnatbl <- arrow::read_feather($rnaarrownm))
""";
```

## Secondary processing steps

- The next step is, for each chromosome, to create an array of the reference intervals from the start and stop positions.
- With [IntervalTrees.jl](https://github.com/BioJulia/IntervalTrees.jl) we will use its `Interval` type, but we start just using ranges to represent an interval.
- The interval represented on a row of a `.bed` file is, in 0-based positions, `start:(stop - 1)`.
- We could equally well use 1-based positions `(start + 1):stop` as long as we are consistent.
- There is a small advantage in incrementing `start` rather than decrementing `stop` if the integer type happens to be unsigned.
- We define methods for an `asrange` function that returns the range from a `start/stop` pair.
- Methods are defined for two integers or for a `NamedTuple`, which is what a row of a rowtable is.
- `one(x)` is used instead of the literal `1` to preserve types (see also `?oneunit`, which is slighly more general).
```{julia}
asrange(start, stop) = (start + one(start)):stop
asrange(r::NamedTuple) = asrange(r.start, r.stop)
```

::: {.callout-note}
These method definitions use the compact "one-liner" syntax.
:::

### Create a dictionary of sorted vectors of ranges

- The split by chromosome is implemented as a dictionary (`Dict`).
- For convenience we convert the `chromo` value from `String` to `Symbol`, which is easier to type.

```{julia}
function chromodict(tbl)
  rtbl = Tables.rowtable(tbl)
  valtyp = Vector{typeof(asrange(first(rtbl)))}
  result = Dict{Symbol,valtyp}()
  for r in rtbl
    push!(get!(result, Symbol(r.chromo), valtyp()), asrange(r))
  end
  return result
end
annodict = chromodict(annotbl)
```

- Note that the intervals are not disjoint, which will throw off the calculation of proportion overlap as implemented in the code in the biofast repository.

```{julia}
first(annodict[:chr05], 7)
```

- For convenience we also convert `rnatbl` to a similar dictionary.

```{julia}
rnadict = chromodict(rnatbl)
```

## Row tables and column tables

- `DataFrame`s and `Arrow.Table`s are examples of column-oriented tables. (Another possibility is a `NamedTuple` of `Vector`s.)
- Sometimes we want to iterate over rows of a table, as in the `chromodict` function.
- Row-tables are convenient for iterating over rows, including constructing a table by appending rows.
- Column-tables are convenient for operating on entire columns, as is done in the `DataFrames` package
- The `Tables` package provides an interface for the two types, including generic functions `columntable` and `rowtable` that allow for lazy views of column or row tables as the other type.

### Counting overlapping sequences

- The first task is to take a `target` interval from the `rna` table and determine the number of `anno` intervals for that chromosome that have a nonempty intersection.
- We also want to know the number of elements in the intersection (the coverage) compared to the size of the `target`.
- The `coverage` function returns a `NamedTuple`, corresponding to a row in a row-table.

```{julia}
function coverage(target::UnitRange{T}, reference::Vector{UnitRange{T}}) where {T}
  n = 0
  overlap = BitSet()
  for h in reference
    i = intersect(target, h)
    if !isempty(i)
      n += 1
      union!(overlap, i)
    end
  end
  return (;
    start=first(target) - one(T),
    stop=last(target),
    nover=T(n),
    noverbp=T(length(overlap)),
    flen=T(length(target)),
  )
end
coverage(rnadict[:chr05][2], annodict[:chr05])
```

::: {.callout-note}
- While creating these notes we discovered a [bug](https://github.com/JuliaLang/julia/pull/45574) in the `union!` method called here.
- There was a [PR](https://github.com/JuliaLang/julia/pull/45578) to fix it the next morning.
- Versions of Julia prior to 1.8.0-rc2 can (and probably will) return an incorrect value of `noverbp`.
:::

- The final stage is performing the overlap calculation for the entire vector of target features on a particular chromosome
- This can be written as a comprehension

```{julia}
function chromooverlap(targetdict, refdict, sym)
  return [coverage(t, refdict[sym]) for t in targetdict[sym]]
end
```

```{julia}
chr21over = DataFrame(chromooverlap(rnadict, annodict, :chr21))
```

```{julia}
extrema(chr21over.nover)
```

```{julia}
@time chromooverlap(rnadict, annodict, :chr21);
```

- A slightly wordier version can take advantage of multiple threads, if available.

```julia
function chromooverlap(targetdict, refdict, sym)
  refs = refdict[sym]
  targets = targetdict[sym]
  result = similar(targets, typeof(coverage(first(targets), refs)))
  Threads.@threads for i in eachindex(targets, result)
    result[i] = coverage(targets[i], refs)
  end
  return result
end
```

## Using IntervalTrees.jl

- `chromooverlap` implements a naive approach that ends up intersecting every interval in the targets with every interval in the reference set.
- The intersection operation can be much faster if we create `IntervalTree`s from the reference set of intervals
- We can use the current `chromooverlap` if we create an dictionary of `IntervalTree`s and a new method for `coverage`.

```{julia}
asinterval(r::NamedTuple) = Interval(r.start + one(r.start), r.stop)
function intervaltreedict(tbl)
  rtbl = rowtable(tbl)
  stype = typeof(first(rtbl).start)
  itype = typeof(asinterval(first(rtbl)))
  ivecdict = Dict{Symbol, Vector{itype}}()
  for r in rtbl
    push!(get!(ivecdict, Symbol(r.chromo), Vector{itype}[]), asinterval(r))
  end
  result = Dict{Symbol, IntervalTree{stype, itype}}()
  for (k, v) in ivecdict
    result[k] = IntervalTree{stype, itype}(sort!(v))
  end
  return result
end
annoitrdict = intervaltreedict(annotbl);
```

- The `intersect` method for an `IntervalTree` and a `(first, last)` Tuple returns the intervals from the tree, not the intersection of those intervals with `first:last`.
- We need to create those intersections as part of the `union!` call.

```{julia}
function coverage(target::UnitRange{T}, reference::IntervalTree{T}) where {T}
  stop = last(target)
  ft = first(target)
  n = 0
  overlap = empty!(BitSet([]))
  for i in intersect(reference, (ft, stop))
    n += 1
    union!(overlap, intersect(target, first(i):last(i)))
  end
  return (;
    start = ft - one(stop),
    stop = stop,
    nover = T(n),
    noverbp = T(length(overlap)),
    flen = T(length(target)),
  )
end
coverage(rnadict[:chr05][2], annoitrdict[:chr05])
```

```{julia}
chr21over == DataFrame(chromooverlap(rnadict, annoitrdict, :chr21))
```

```{julia}
@time chromooverlap(rnadict, annoitrdict, :chr21);
```

- The timings were done with `:chr21` because the number of intervals is small.  Repeat with `:chr01` for more realistic timings.

## Conclusions

- Julia provides an impressive array of tools for Bioinformatics and similar tasks
- We have shown the use of
[Arrow.jl](https://github.com/apache/arrow-julia),
[CategoricalArrays.jl](https://github.com/JuliaData/CategoricalArrays.jl)
[CSV.jl](https://github.com/JuliaData/CSV.jl),
[DataFrames](https://github.com/JuliaData/DataFrames.jl),
and
[Tables.jl](https://github.com/JuliaData/Tables.jl) for data input, storage and manipulation.
- Although not shown here [DataFrameMacros.jl](https://github.com/jkrumbiegel/DataFrameMacros.jl) or ([DataFramesMeta.jl](https://github.com/JuliaData/DataFramesMeta.jl)) and [Chain.jl](https://github.com/jkrumbiegel/Chain.jl) are worth considering if you start working with DataFrames.
- We have also shown the use of
[PyCall.jl](https://github.com/JuliaPy/PyCall.jl) and
[RCall.jl](https://github.com/JuliaInterop/RCall.jl) for running and communicating with other language systems within Julia.
- We also showed the use of utility packages [Downloads.jl](https://JuliaLang/Downloads.jl) and [Tar.jl](https://github.com/JuliaIO/Tar.jl) for scripting, say within [Quarto](https://quarto.org) documents like these.
- Take a moment to look at the repositories for many of these Julia packages.  Most (all?) of them are 100% Julia code.

## Version information

```{julia}
versioninfo()
```
