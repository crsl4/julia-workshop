---
title: "Session 2: Data Tables and Arrow files"
jupyter: julia-1.8
---
Load packages to be used

```{julia}
#| code-fold: show
using Arrow           # Arrow storage and file format
using CSV             # CSV and related files
using Downloads       # file downloads
using DataFrames      # versatile tabular data format
using IntervalTrees   # interval trees implemented by BioJulia
using PooledArrays    # compact, factor-like storage
using PyCall          # run Python within a Julia session
using RCall           # run R within a Julia session
using Tables          # row- or column-oriented data tables
using Tar             # tar archive utilities
```

## Objectives

- Use an example of computing interval overlaps to introduce Julia facilities for working with tabular data.
- Introduce the Arrow format for tabular data and demonstrate its use in Julia, Python/Pandas and R.
- Show a naive approach to computing overlaps
- Modify the approach to use [IntervalTrees.jl](https://github.com/BioJulia/IntervalTrees.jl)
- (Time permitting) An approach based on [cgranges](https://github.com/lh3/cgranges).

## Task and sample data

- [lh3/biofast](https://github.com/lh3/biofast) provides benchmark code for comparing programming languages on Bioinformatics tasks.
- One of these tasks, an "interval query", takes two [.bed files](https://en.wikipedia.org/wiki/BED_(file_format)) to compare.
- One file contains a reference set of intervals, the other contains target intervals.
- For each target interval, determine which reference intervals overlap with it.
- In the benchmark both the number of reference intervals that overlap with a target and the proportion of the target covered by the overlap are computed.
- It appears that the calculation of the proportion of overlap assumes that the reference intervals are disjoint.  We will not make that assumption.

## Sample data

- the data sets for the benchmark are available as `biofast-data-v1.tar.gz` at [biofast-data-v1](https://github.com/lh3/biofast/releases/tag/biofast-data-v1)

```{julia}
datadir = "biofast-data-v1"
if !isdir(datadir)
  tarball = "biofast-data-v1.tar.gz"
  if !isfile(tarball)
    dataurl = joinpath("https://github.com/lh3/biofast/releases/download", datadir, tarball)
    Downloads.download(dataurl, tarball)
  end
  tmpdir = Tar.extract(h -> endswith(h.path, ".bed"), `zcat ./$tarball`)
  mv(joinpath(tmpdir, datadir), datadir)
end
run(`ls -lh $datadir`);
```

- the `.tar.gz` file is about 0.5 GB. but most of that is the data for the FASTQ parsing test.

## Initial processing


- The `.bed` file, in this case, are simple tab-separated-value files.
- Each of the language implementations in the benchmark contains code to parse lines of the `.bed` files producing a `String` and two `Int32` values.
- Why go through this parsing of text files to create a numeric representation in each language and then store the results again as text files?
- Writing code to parse a CSV or TSV file is tedious and error prone.
- But skilled people have put a lot of work into creating packages to do just that.
- More importantly they have tested, debugged, and documented their packages.
- The `CSV.read` function reads and parses a file and converts it to a type specified by the second argument.
- As is common for such functions, there are many, many optional named arguments
- We could call it as

```{julia}
annodf = CSV.read(
  "./biofast-data-v1/ex-anno.bed",
  DataFrame;
  header=["chromo", "start", "stop"],
  delim='\t',
  types=[String, Int32, Int32],
)
```

- It turns out that both of the `.bed` files contain many duplicate rows.
- As row order is not important, we first sort the `DataFrame` then iterate over rows skipping any that are equal to the previous rows.
- Before sorting I will change strings like `"chr1"` to `"chr01"` so that sorting the strings also orders by chromosome number.

```{julia}
replacements =  ["chr$i" => "chr0$i" for i in 1:9]
```

```{julia}
replace!(annodf[!, :chromo], replacements...)
```


## Row tables and column tables

- [Tables.jl](https://github.com/JuliaData/Tables.jl) provides an interface between row-oriented tables and column-oriented tables.
- In general a row-oriented table looks like a `Vector{NamedTuple}` and a column-oriented table looks like a `NamedTuple` of `Vector`s.
- Methods can be written for general "table-like" arguments and the interface takes care of the mapping details.
- Row tables allow efficient iteration over rows; column tables allow for operations on entire columns.

```{julia}
function dropdups(df::DataFrame)
  rtbl = rowtable(sort!(df))  # prepare to iterate over rows
  prev = last(rtbl)           # any row that is != first(rtbl)
  result = sizehint!(typeof(prev)[], length(rtbl) ÷ 4)
  for r in rtbl
    r == prev || push!(result, r)
    prev = r
  end
  return DataFrame(result)
end
annordf = dropdups(annodf,)
```

## Arrow file format

- The [Arrow project](https://arrow.apache.org) defines a memory and file format for storing and manipulating column-oriented, static, tables (i.e. like data frames in R, Python/Pandas, and Julia)
- When writing to a file either 'lz4' or 'zstd' compression can be used.
- Metadata on the names and types of columns is automatically stored.  Additional column or table metadata can be specified.

```{julia}
Arrow.write(
  "./biofast-data-v1/ex-anno.arrow",
  transform!(annordf, :chromo => PooledArray => :chromo);
  compress=:lz4,
  metadata=[
    "url" =>
    "https://github.com/lh3/biofast/releases/tag/biofast-data-v1",
  ],
)
```

::: {.callout-note}
In the call to `Arrow.write` the positional arguments and the named arguments are separated with `;` rather than `,`.
This is optional in these calls.
However, this convention can be used to indicate a named argument value is the same name as an object in an active namespace.
:::

```{julia}
rnaarrownm = let
  bednm = "./biofast-data-v1/ex-rna.bed"
  header = [:chromo, :start, :stop]
  delim = '\t'
  types = [String, Int32, Int32]
  rnadf = CSV.read(bednm, DataFrame; header, delim, types)
  replace!(rnadf[!, :chromo], replacements...)
  compress = :lz4
  metadata = [
    "url" => 
    "https://github.com/lh3/biofast/releases/tag/biofast-data-v1",
  ]
  Arrow.write(
    string(first(splitext(bednm)), ".arrow"),
    transform!(dropdups(rnadf), :chromo => PooledArray => :chromo);
    compress,
    metadata,
  )
end
```

```{julia}
run(`ls -lh $datadir`);
```

## Reading Arrow files in Julia

```{julia}
annotbl = Arrow.Table("./biofast-data-v1/ex-anno.arrow")
```

- Although the schema describes the `chromo` column as `String`s the values are dictionary encoded such that each value is represented by one byte.

```{julia}
typeof(annotbl.chromo)
```

```{julia}
rnatbl = Arrow.Table(rnaarrownm)
```

- We can use operations like split-apply-combine on these tables to summarize properties

```{julia}
innerjoin(
  combine(groupby(DataFrame(rnatbl), :chromo), nrow => :nrna),
  combine(groupby(DataFrame(annotbl), :chromo), nrow => :nanno);
  on=:chromo,
)  
```

## Reading Arrow files in Python

- In Python (and in R) the Arrow file format is confounded with an earlier file format called Feather and referred to as `Feather V2`.
- The `pyarrow` package includes `pyarrow.feather`.  Its use in a Python session looks like

```python
>>> import pyarrow.feather as fea
>>> fea.read_table('./biofast-data-v1/ex-rna.arrow')
pyarrow.Table
chromo: dictionary<values=string, indices=int8, ordered=0> not null
start: int32 not null
stop: int32 not null
----
chromo: [  -- dictionary:
["chr01","chr02","chr03","chr04","chr05",...,"chr20","chr21","chr22","chrX","chrY"]  -- indices:
[0,0,0,0,0,...,23,23,23,23,23]]
start: [[14354,14359,14361,14361,14366,...,18992169,18992297,24362035,24362037,25307904]]
stop: [[24892,24855,14672,16878,24894,...,18992298,18992676,24362135,24362201,25308109]]
>>> fea.read_feather('./biofast-data-v1/ex-rna.arrow')
        chromo     start      stop
0        chr01     14354     24892
1        chr01     14359     24855
2        chr01     14361     14672
3        chr01     14361     16878
4        chr01     14366     24894
...        ...       ...       ...
4685075   chrY  18992169  18992298
4685076   chrY  18992297  18992676
4685077   chrY  24362035  24362135
4685078   chrY  24362037  24362201
4685079   chrY  25307904  25308109

[4685080 rows x 3 columns]
```
- `read_table` returns a `Table` object, `read_feather` returns a Pandas dataframe.

- The `PyCall` package for `Julia` starts a Python process and allows communication with it, including data transfer.
- I use this instead of the Python REPL when working with both Julia and Python

```{julia}
fea = pyimport("pyarrow.feather")
fea.read_table(rnaarrownm)
```

- Notice that the `chromo` column has been converted from strings to a dictionary encoding of the unique values of the strings and 8-bit integer indices into this dictionary.

## Reading Arrow files in R

- In R the `arrow::read_feather` function returns a tibble.  In an R session it looks like

```r
> library(tibble)
> arrow::read_feather("./biofast-data-v1/ex-rna.arrow")
# A tibble: 4,685,080 × 3
   chromo start  stop
   <fct>  <int> <int>
 1 chr01  14354 24892
 2 chr01  14359 24855
 3 chr01  14361 14672
 4 chr01  14361 16878
 5 chr01  14366 24894
 6 chr01  14370 14989
 7 chr01  14396 24894
 8 chr01  14397 17733
 9 chr01  14398 24894
10 chr01  14399 15977
# … with 4,685,070 more rows
```

- The `RCall` package in Julia allows for running an R process within a Julia session

```{julia}
R"""
library(tibble)
glimpse(rnatbl <- arrow::read_feather($rnaarrownm))
""";
```

## Secondary processing steps

- The next step is, for each chromosome, to create an array of the reference intervals from the start and stop positions.
- [IntervalTrees.jl](https://github.com/BioJulia/IntervalTrees.jl) defines an `Interval` type but we will start just using ranges to represent an interval.
- The interval represented on a row of a `.bed` file is, in 0-based positions, `start:(stop - 1)`.
- We could equally well use 1-based positions `(start + 1):stop` as long as we are consistent.
- There is a small advantage in incrementing `start` rather than decrementing `stop` if the integer type happens to be unsigned.
- We define methods for an `asrange` function that returns the range from a `start/stop` pair.
- Methods are defined for two integers or for a `NamedTuple`, which is what a row of a rowtable is.
- `one(x)` is used instead of the literal `1` to preserve types (see also `?oneunit`, which is slighly more general).
```{julia}
asrange(start, stop) = (start + one(start)):stop
asrange(r::NamedTuple) = asrange(r.start, r.stop)
```

::: {.callout-note}
These method definitions use the compact "one-liner" syntax.
:::

### Create a dictionary of sorted vectors of ranges

- The split by chromosome is implemented as a dictionary (`Dict`).
- For convenience we convert the `chromo` value from `String` to `Symbol`, which is easier to type.

```{julia}
function chromodict(tbl)
  rtbl = Tables.rowtable(tbl)
  valtyp = Vector{typeof(asrange(first(rtbl)))}
  result = Dict{Symbol,valtyp}()
  for r in rtbl
    push!(get!(result, Symbol(r.chromo), valtyp()), asrange(r))
  end
  return result
end
annodict = chromodict(annotbl)
```

- Also, the intervals are not disjoint, which will throw off the calculation of proportion overlap as implemented in the code in the biofast repository.

```{julia}
first(annodict[:chr05], 7)
```

- For convenience we also convert `rnatbl` to dictionary of unique, sorted `Vector{UnitRange{Int32}}`.

```{julia}
rnadict = chromodict(rnatbl)
```

### Counting overlapping sequences

- The first task is to take a `target` interval from the `rna` table and determine the number of `anno` intervals for that chromosome that have a nonempty intersection.
- We also want to know the number of elements in the intersection (the coverage) compared to the size of the `target`.
- The `coverage` function returns a `NamedTuple`, corresponding to a row in a row-table.
```{julia}
function coverage(target::UnitRange{T}, reference::Vector{UnitRange{T}}) where {T}
  n = 0
  overlap = empty!(BitSet([]))
  for h in reference
    i = intersect(target, h)
    if !isempty(i)
      n += 1
      union!(overlap, i)
    end
  end
  start = first(target) - one(T)
  stop = last(target)
  nover = T(n)
  noverbp = T(length(overlap))
  flen = T(length(target))
  return (; start, stop, nover, noverbp, flen)
end
coverage(rnadict[:chr05][2], annodict[:chr05])
```

- the final stage is performing the overlap calculation for the entire vector of features on a particular chromosome

```{julia}
function chromooverlap(targetdict, refdict, sym)
  refs = refdict[sym]
  targets = targetdict[sym]
  result = similar(targets, typeof(coverage(first(targets), refs)))
  Threads.@threads for i in eachindex(targets, result)
    result[i] = coverage(targets[i], refs)
  end
  return result
end
```

- this version of `chromooverlap` takes advantage of multiple threads if available.

```{julia}
chr21over = DataFrame(chromooverlap(rnadict, annodict, :chr21))
```

```{julia}
extrema(chr21over.nover)
```

```{julia}
@time chromooverlap(rnadict, annodict, :chr21);
```

## Using IntervalTrees.jl

- `chromooverlap` implements a naive approach that ends up intersecting every interval in the targets with every interval in the reference set.
- Using an `IntervalTree` from [IntervalTrees.jl](https://github.com/BioJulia/IntervalTrees.jl) this operation can be much faster
- We can use the current `chromooverlap` if we create an dictionary of `IntervalTree`s and a new method for `coverage`.

```{julia}
asinterval(r::NamedTuple) = Interval(r.start + one(r.start), r.stop)
function intervaltreedict(tbl)
  rtbl = rowtable(tbl)
  stype = typeof(first(rtbl).start)
  itype = typeof(asinterval(first(rtbl)))
  ivecdict = Dict{Symbol, Vector{itype}}()
  for r in rtbl
    push!(get!(ivecdict, Symbol(r.chromo), Vector{itype}[]), asinterval(r))
  end
  result = Dict{Symbol, IntervalTree{stype, itype}}()
  for (k, v) in ivecdict
    result[k] = IntervalTree{stype, itype}(sort!(v))
  end
  return result
end
annoitrdict = intervaltreedict(annotbl);
```

- The `intersect` method for an `IntervalTree` and a `(first, last)` Tuple returns the intervals from the tree, not the intersection of those intervals with `first:last`.
- We need to create those intersections as part of the `union!` call.

```{julia}
function coverage(target::UnitRange{T}, reference::IntervalTree{T}) where {T}
  stop = last(target)
  ft = first(target)
  n = 0
  covered = empty!(BitSet([]))
  for i in intersect(reference, (ft, stop))
    n += 1
    union!(covered, intersect(target, first(i):last(i)))
  end
  start = ft - one(stop)
  nover = T(n)
  noverbp = T(length(covered))
  flen = T(length(target))
  return (; start, stop, nover, noverbp, flen)
end
```

```{julia}
chr21over == DataFrame(chromooverlap(rnadict, annoitrdict, :chr21))
```

```{julia}
@time chromooverlap(rnadict, annoitrdict, :chr21);
```

- The timings were done with `:chr21` because the number of intervals is small.  Repeat with `:chr01` for more realistic timings.

## Configuration

```{julia}
versioninfo()
```
