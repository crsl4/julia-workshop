[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia Workshop for Data Science",
    "section": "",
    "text": "Schedule\n\n\n\nTime\nTopic\nPresenter\n\n\n\n\n11:00 - 11:30\nSession 1: Get Started with Julia\nClaudia Solis-Lemus\n\n\n11:30 - 12:30\nSession 2a: Data Tables and Arrow files\nDouglas Bates\n\n\n12:30 - 1:00\nSession 2b: Interval Overlap\nDouglas Bates\n\n\n1:00 - 2:00\nLunch break\n\n\n\n2:00 - 3:00\nSession 3: Model fitting\n\n\n\n3:00 - 4:00\nSession 4: Hands-on exercise\nSam Ozminkowski and Bella Wu\n\n\n4:00 - 4:15\nCoffee break\n\n\n\n4:15 - 5:00\nPresentation of selected participants’ scripts and Q&A\n\n\n\n5:00 - 5:30\nSession 5: Other important Data Science tools\nClaudia Solis-Lemus\n\n\n5:30 - 6:00\nSession 6: Conclusions and questions\nClaudia Solis-Lemus\n\n\n\n\n\nIn preparation for the workshop\nParticipants are required to follow the next steps before the day of the workshop:\n\nGit clone the workshop repository: git clone https://github.com/crsl4/julia-workshop.git\nInstall Julia. The recommended option is to use JuliaUp:\n\n\nWindows: winget install julia -s msstore\nMac and Linux: curl -fsSL https://install.julialang.org | sh\nHomebrew users: brew install juliaup\n\nAfter JuliaUp is installed, you can install different Julia versions with:\njuliaup add release  ## installs release version\njuliaup add rc       ## installs release candidate version\njuliaup st           ## status of julia versions installed\njuliaup default rc   ## make release candidate version the default\n\nChoose a dataset along with a script to analyze it written in another language (R or python) as we will spend part of the workshop translating participants’ scripts to Julia."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This tutorial will provide an introduction to key Data Science tools in Julia such as data management with Arrow.jl and Tables.jl and (Generalized) linear mixed models with GLMM.jl and MixedModels.jl. Unlike widely used R packages, all packages that we will describe are written 100% in Julia thus illustrating the language’s potential to overcome the two-language problem.\nThis tutorial will appeal to anyone interested in learning more about Julia and some of the existing Julia packages that are already available for Statistics and Data Science. In addition to lectures, participants will engage in hands-on exercises. For example, participants will bring a dataset of their choice along with an existing script written in another language (R or python) that performs certain data analyses. During the tutorial, participants will translate their work to Julia in-order to compare running times and ease of programming."
  },
  {
    "objectID": "session1-get-started.html",
    "href": "session1-get-started.html",
    "title": "Session 1: Getting started with Julia",
    "section": "",
    "text": "“We want a language that is\n\nopen source\nwith the speed of C\nobvious, familiar mathematical notation like Matlab\nas usable for general programming as Python\nas easy for statistics as R\nas natural for string processing as Perl\nas powerful for linear algebra as Matlab\nas good at gluing programs together as the shell\ndirt simple to learn, yet keeps the most serious hackers happy”\n\n\n\n\n\nComparison with other languages: Julia touts its speed edge over Python and R\nUsed for large-scale projects like CliMA 0.1: a first milestone in the next generation of climate models\n\nClimateMachine.jl\n\nJulia adoption accelerated at a rapid pace in 2020:\n\n\n\n\n\n\n\n\nUse the REPL as a sophisticated calculator\nRealize that you are repeating many operations, so you decide to write some functions\nTo organize all your functions, you begin scripting\nYou want to share your code with others and thus, you want to write a package\nYour package is actually used by others and thus, it should be optimized and have good performance\n\nJulia offers many advantages to data science programmers such as avoid the two-language problem and existing tools that allows programmers to write efficient code without having to write everything from scratch!"
  },
  {
    "objectID": "session1-get-started.html#how-do-i-write-code",
    "href": "session1-get-started.html#how-do-i-write-code",
    "title": "Session 1: Getting started with Julia",
    "section": "How do I write code?",
    "text": "How do I write code?"
  },
  {
    "objectID": "session1-get-started.html#installing-dependencies-in-a-project-environment",
    "href": "session1-get-started.html#installing-dependencies-in-a-project-environment",
    "title": "Session 1: Getting started with Julia",
    "section": "Installing dependencies in a project environment",
    "text": "Installing dependencies in a project environment\nThere are two alternatives:\n\nUsing an existing project with dependencies already in Project.toml (this will be the case when you are collaborating with someone that already set up the project dependencies)\nSet up the dependencies for your project on your own (this will be the case if your project is new)\n\nFor this workshop, participants will use the workshop GitHub repository as the existing project that already has all the dependencies. However, we also show the steps below to create a new project from scratch.\n\n1. Working on an existing project environment\nGit clone the repository:\ngit clone https://github.com/crsl4/julia-workshop.git\nOpen julia and activate the package with:\njulia --project\nAlternatively, you can open julia normally, and type ] activate .\nThen, instantiate the package (install dependencies) with:\n] instantiate\n] update\nNow, you should be able to follow along the workshop commands. Trouble-shooting might be needed when we reach the interoperability with Python and R as certain libraries or packages might need to be installed too.\n\n\n2. Creating a new project environment\nCreate a folder in the terminal:\nmkdir myProject\ncd myProject\nOpen Julia inside your folder, and activate your environment with:\n(@v1.8) pkg> activate .\nInstall the packages that we need. For example, the packages needed for today’s workshop are:\njulia> ENV[\"PYTHON\"] = \"\"\n(myproject) pkg> add PyCall\n(myproject) pkg> add IJulia\n(myproject) pkg> build IJulia\n(myproject) pkg> add MixedModels\n(myproject) pkg> add RCall\n(myproject) pkg> add Arrow\n(myproject) pkg> add DataFrames\n(myproject) pkg> add Tables\n(myproject) pkg> add RangeTrees\nTwo files are noteworthy:\n\nProject.toml: Defines project\nManifest.toml: Contains exact list of project dependencies\n\nshell> head Project.toml\n[deps]\nArrow = \"69666777-d1a9-59fb-9406-91d4454c9d45\"\nDataFrames = \"a93c6f00-e57d-5684-b7b6-d8193f3e46c0\"\nIJulia = \"7073ff75-c697-5162-941a-fcdaad2a7d2a\"\nMixedModels = \"ff71e718-51f3-5ec2-a782-8ffcbfa3c316\"\nPyCall = \"438e738f-606a-5dbb-bf0a-cddfbfd45ab0\"\nRCall = \"6f49c342-dc21-5d91-9882-a32aef131414\"\nTables = \"bd369af6-aec1-5ad0-b16a-f7cc5008161c\"\n\n\nshell> head Manifest.toml\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = \"1.8.0-beta3\"\nmanifest_format = \"2.0\"\nproject_hash = \"01baf737705b090869a607b779c699f83bbeb154\"\n\n[[deps.ArgTools]]\nuuid = \"0dad84c5-d112-42e6-8d28-ef12dabb789f\"\nversion = \"1.1.1\"\nLook at your Project.toml and Manifest.toml files after installation. They have all the necessary information about your session.\nThe packages have a uuid string which is the universally unique identifier.\nMore on the Project.toml and Manifest.toml files here."
  },
  {
    "objectID": "session1-get-started.html#easy-share-with-collaborators",
    "href": "session1-get-started.html#easy-share-with-collaborators",
    "title": "Session 1: Getting started with Julia",
    "section": "Easy share with collaborators",
    "text": "Easy share with collaborators\nShare your project to colleagues. Send your entire project folder to your colleague, and all they need to do is:\njulia> cd(\"path/to/project\")\npkg> activate .\npkg> instantiate\nAll required packages and dependencies will be installed. Scripts that run in your computer will also run in their computer."
  },
  {
    "objectID": "session2a-tables-and-arrow.html",
    "href": "session2a-tables-and-arrow.html",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "",
    "text": "Code\nusing Arrow             # Arrow storage and file format\nusing CategoricalArrays # similar to the factor type in R\nusing CSV               # read/write CSV and similar formats\nusing Downloads         # file downloads\nusing DataFrames        # versatile tabular data format\nusing GZip              # utilities for compressed files\nusing RCall             # run R within Julia\nusing Tar               # tar archive utilities\n\n\nDownloads, Gzip and Tar are included just to demonstrate downloading and extracting tar files within Julia.\nYou may find it easier to simply click on the download link and extract the files by hand.\nDownloading and extracting within Julia, as shown here, has a greater chance of working across various operating systems and environments in a workshop like this.\nRCall is included to show the use of other systems running within Julia.\nYou can instead use your favorite environment, such as jupyterlab or RStudio, to run Python or R\nNote that the quarto notebooks for these notes are easily converted, e.g. quarto convert notebookname.qmd, to Jupyter notebooks.\n\n\n\n\n\n\n\nNote\n\n\n\nBoxes like this contain comments on Julia syntax and semantics in code examples."
  },
  {
    "objectID": "session2a-tables-and-arrow.html#task-and-sample-data",
    "href": "session2a-tables-and-arrow.html#task-and-sample-data",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Task and sample data",
    "text": "Task and sample data\n\nLi Heng provides benchmark code and sample data for comparing programming languages on Bioinformatics tasks in his biofast repository.\nOne of these tasks, an interval query, takes two .bed files to compare.\nOne file, ex-anno.bed, contains a reference set of intervals; the other, ex-rna.bed, contains target intervals.\nFor each target interval, determine which reference intervals overlap with it.\nIn the benchmark both the number of reference intervals that overlap with a target and the proportion of the target covered by the overlap are computed.\nNote that the calculation of the proportion of overlap must allow for overlapping intervals in the reference set, as shown in this figure"
  },
  {
    "objectID": "session2a-tables-and-arrow.html#extract-the-files-of-interest-if-not-already-present",
    "href": "session2a-tables-and-arrow.html#extract-the-files-of-interest-if-not-already-present",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Extract the files of interest (if not already present)",
    "text": "Extract the files of interest (if not already present)\n\nisdir(datadir) || mkdir(datadir)\nbedfnms = joinpath.(datadir, [\"ex-anno.bed\", \"ex-rna.bed\"])\ntoextract = filter(!isfile, bedfnms)  # don't overwrite existing files\nif !isempty(toextract)\n  tmpdir = gzopen(tarball, \"r\") do io\n    Tar.extract(h -> in(h.path, toextract), io)\n  end\n  for pathnm in toextract\n    mv(joinpath(tmpdir, pathnm), pathnm; force = true)\n  end\nend\nfilter(endswith(\".bed\"), readdir(datadir))\n\n2-element Vector{String}:\n \"ex-anno.bed\"\n \"ex-rna.bed\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe call joinpath.(datadir, [\"ex-anno.bed\", \"ex-rna.bed\"]) is an example of dot vectorization.\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe expression h -> in(h.path, toextract) defines an anonymous function, in the “stabby lambda” syntax, to be used as a predicate in Tar.extract.\n\nmethods(Tar.extract)\n\n# 4 methods for generic function extract: extract(predicate::Function, tarball::Union{Base.AbstractCmd, AbstractString, IO}) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:218  extract(predicate::Function, tarball::Union{Base.AbstractCmd, AbstractString, IO}, dir::Union{Nothing, AbstractString}; skeleton, copy_symlinks, set_permissions) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:218  extract(tarball::Union{Base.AbstractCmd, AbstractString, IO}) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:248  extract(tarball::Union{Base.AbstractCmd, AbstractString, IO}, dir::Union{Nothing, AbstractString}; skeleton, copy_symlinks, set_permissions) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:248 \n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe ‘do/end’ block is yet another way of writing an anonymous function passed as the first argument in the call to gzopen, even though it occurs after that call in the code.\n\nmethods(gzopen)\n\n# 4 methods for generic function gzopen: gzopen(fname::AbstractString) in GZip at /home/bates/.julia/packages/GZip/JNmGn/src/GZip.jl:264  gzopen(fname::AbstractString, gzmode::AbstractString) in GZip at /home/bates/.julia/packages/GZip/JNmGn/src/GZip.jl:263  gzopen(fname::AbstractString, gzmode::AbstractString, gz_buf_size::Integer) in GZip at /home/bates/.julia/packages/GZip/JNmGn/src/GZip.jl:236  gzopen(f::Function, args...) in GZip at /home/bates/.julia/packages/GZip/JNmGn/src/GZip.jl:267 \n\n\nThe effect is to uncompress the file into a stream, process the stream in this anonymous function, then close the stream.\n\n\n\n\n\n\n\n\nNote\n\n\n\nBecause Tar.extract is conservative about overwriting files and requires that the directory into which the files are extracted be empty, we extract to a freshly-created temporary directory then move the files to the desired location.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nIt is common for packages providing utilities to avoid name conflicts by not exporting any names from their namespace (or Module).\nThe fully qualified name, Tar.extract, can always be used - similar to Python naming conventions.\nIf a package exports a name, say foo, then after the using FooPackage directive, the unqualified name foo can be used.\nThe varinfo function provides a listing of the names exported by a Package (formally the package’s Module).\nCompare the result below with that of, say, varinfo(DataFrames).\n\nvarinfo(Tar)\n\n\n\nname\nsize\nsummary\n\n\n\n\nTar\n856.961 KiB\nModule"
  },
  {
    "objectID": "session2a-tables-and-arrow.html#reading-arrow-files-in-julia",
    "href": "session2a-tables-and-arrow.html#reading-arrow-files-in-julia",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Reading Arrow files in Julia",
    "text": "Reading Arrow files in Julia\n\nannotbl = Arrow.Table(\"./biofast-data-v1/ex-anno.arrow\")\n\nArrow.Table with 573806 rows, 3 columns, and schema:\n :chromo  String\n :start   Int32\n :stop    Int32\n\nwith metadata given by a Base.ImmutableDict{String, String} with 1 entry:\n  \"url\" => \"https://github.com/lh3/biofast/releases/tag/biofast-data-v1\"\n\n\n\nAlthough the schema describes the chromo column as Strings the values are dictionary encoded such that each value is represented by one byte.\n\n\ntypeof(annotbl.chromo)\n\nArrow.DictEncoded{String, Int8, Arrow.List{String, Int32, Vector{UInt8}}}\n\n\n\n@time rnatbl = Arrow.Table(rnaarrownm)\n\n  0.074396 seconds (326 allocations: 77.842 MiB)\n\n\nArrow.Table with 4685080 rows, 3 columns, and schema:\n :chromo  String\n :start   Int32\n :stop    Int32\n\nwith metadata given by a Base.ImmutableDict{String, String} with 1 entry:\n  \"url\" => \"https://github.com/lh3/biofast/releases/tag/biofast-data-v1\"\n\n\n\nWe can use operations like split-apply-combine on these tables to summarize properties\n\n\nannogdf = groupby(DataFrame(annotbl), :chromo)\nrnagdf = groupby(DataFrame(rnatbl), :chromo)\ninnerjoin(\n  combine(rnagdf, nrow => :nrna),\n  combine(annogdf, nrow => :nanno);\n  on = :chromo,\n)\n\n\n24 rows × 3 columnschromonrnanannoStringInt64Int641chr01453114527892chr02298278425633chr03251858347694chr04132781225005chr05225898260856chr06307747249357chr07217038276138chr08141205216039chr091651812018910chr101622562006111chr112865843402112chr122920023352413chr1376779946414chr141714021999515chr151717362218716chr161925952827617chr172883483588818chr18604291017919chr193447753545120chr201099791238721chr2151720651822chr221329561272423chrX1503301761824chrY892467\n\n\n\nIn the next section we will use data from chr21 for comparative timings, because there are small, but nontrivial, number of intervals in both the reference and target groups."
  },
  {
    "objectID": "session2a-tables-and-arrow.html#reading-arrow-files-in-r",
    "href": "session2a-tables-and-arrow.html#reading-arrow-files-in-r",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Reading Arrow files in R",
    "text": "Reading Arrow files in R\n\nIn R (and in Python) the Arrow file format is confounded with an earlier file format called Feather and referred to as Feather V2.\nIn R the arrow::read_feather function returns a tibble. In an R session it looks like\n\n> library(tibble)\n> arrow::read_feather(\"biofast-data-v1/ex-rna.arrow\")\n# A tibble: 4,685,080 × 3\n   chromo     start      stop\n   <fct>      <int>     <int>\n 1 chr02  216499331 216501458\n 2 chr07  101239611 101245071\n 3 chr19   49487626  49491841\n 4 chr10   80155590  80169336\n 5 chr17   76270411  76271290\n 6 chr06   31268756  31272069\n 7 chr05  170083214 170083368\n 8 chr19   51989731  51989996\n 9 chr18   55225980  55226732\n10 chr16   84565611  84566066\n# … with 4,685,070 more rows\n\nThe RCall package in Julia allows for running an R process within a Julia session.\nOne way of executing R code with RCall is to prepend R to a string. This causes the string to be evaluated in R.\n$-interpolation in the string causes a Julia object to be copied into the R environment and its name in R interpolated.\n\n\nR\"\"\"\nlibrary(tibble)\nglimpse(rnatbl <- arrow::read_feather($rnaarrownm))\n\"\"\";\n\nRows: 4,685,080\nColumns: 3\n$ chromo <fct> chr02, chr07, chr19, chr10, chr17, chr06, chr05, chr19, chr18, …\n$ start  <int> 216499331, 101239611, 49487626, 80155590, 76270411, 31268756, 1…\n$ stop   <int> 216501458, 101245071, 49491841, 80169336, 76271290, 31272069, 1…"
  },
  {
    "objectID": "session2a-tables-and-arrow.html#reading-arrow-files-in-python",
    "href": "session2a-tables-and-arrow.html#reading-arrow-files-in-python",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Reading Arrow files in Python",
    "text": "Reading Arrow files in Python\n\nThe pyarrow package includes pyarrow.feather. Its use in a Python session looks like\n\n>>> import pyarrow.feather as fea\n>>> fea.read_table('./biofast-data-v1/ex-rna.arrow')\npyarrow.Table\nchromo: dictionary<values=string, indices=int8, ordered=0> not null\nstart: int32 not null\nstop: int32 not null\n----\nchromo: [  -- dictionary:\n[\"chr01\",\"chr02\",\"chr03\",\"chr04\",\"chr05\",...,\"chr20\",\"chr21\",\"chr22\",\"chrX\",\"chrY\"]  -- indices:\n[1,6,18,9,16,...,16,15,10,22,0]]\nstart: [[216499331,101239611,49487626,80155590,76270411,...,7014179,75627747,59636724,153785767,182839364]]\nstop: [[216501458,101245071,49491841,80169336,76271290,...,7014515,75631483,59666963,153787586,182887745]]\n>>> fea.read_feather('./biofast-data-v1/ex-rna.arrow')\n        chromo      start       stop\n0        chr02  216499331  216501458\n1        chr07  101239611  101245071\n2        chr19   49487626   49491841\n3        chr10   80155590   80169336\n4        chr17   76270411   76271290\n...        ...        ...        ...\n4685075  chr17    7014179    7014515\n4685076  chr16   75627747   75631483\n4685077  chr11   59636724   59666963\n4685078   chrX  153785767  153787586\n4685079  chr01  182839364  182887745\n\n[4685080 rows x 3 columns]\n\nread_table returns a Table object, read_feather returns a Pandas dataframe.\nThe PyCall package for Julia starts a Python process and allows communication with it, including data transfer.\nI use this instead of the Python REPL when working with both Julia and Python.\nConfiguring Python, Conda, pyarrow, pandas, and PyCall across platforms is sufficiently complicated to almost surely cause failures for some workshop participants. Instead of evaluating this code chunk we quote the results.\n\njulia> using PyCall\njulia> fea = pyimport(\"pyarrow.feather\");\njulia> fea.read_table(rnaarrownm)\nPyObject pyarrow.Table\nchromo: dictionary<values=string, indices=int8, ordered=0> not null\nstart: int32 not null\nstop: int32 not null\n----\nchromo: [  -- dictionary:\n[\"chr01\",\"chr02\",\"chr03\",\"chr04\",\"chr05\",...,\"chr20\",\"chr21\",\"chr22\",\"chrX\",\"chrY\"]  -- indices:\n[1,6,18,9,16,...,16,15,10,22,0]]\nstart: [[216499331,101239611,49487626,80155590,76270411,...,7014179,75627747,59636724,153785767,182839364]]\nstop: [[216501458,101245071,49491841,80169336,76271290,...,7014515,75631483,59666963,153787586,182887745]]"
  },
  {
    "objectID": "session2a-tables-and-arrow.html#version-information",
    "href": "session2a-tables-and-arrow.html#version-information",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Version information",
    "text": "Version information\n\nversioninfo()\n\nJulia Version 1.8.0-rc1\nCommit 6368fdc656 (2022-05-27 18:33 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: 8 × 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, tigerlake)\n  Threads: 6 on 8 virtual cores"
  },
  {
    "objectID": "session2b-interval-overlap.html",
    "href": "session2b-interval-overlap.html",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "",
    "text": "Code\nusing Arrow          # Arrow storage and file format\nusing BenchmarkTools # tools for benchmarking code\nusing DataFrames     # versatile tabular data format\nusing IntervalTrees  # interval trees from BioJulia\nusing Random         # random number generation tools\nusing RangeTrees     # a bespoke implementation of interval trees\nusing Tables         # row- or column-oriented tabular data\n\nusing Base: intersect! # not exported from Base\n\ndatadir = \"biofast-data-v1\";"
  },
  {
    "objectID": "session2b-interval-overlap.html#creating-dictionaries-of-vectorunitrange",
    "href": "session2b-interval-overlap.html#creating-dictionaries-of-vectorunitrange",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Creating dictionaries of Vector{UnitRange}",
    "text": "Creating dictionaries of Vector{UnitRange}\n\nA UnitRange, like 2:10, includes the end points (accessed as first and last).\n\n\ntypeof(2:10), length(2:10), first(2:10), last(2:10)\n\n(UnitRange{Int64}, 9, 2, 10)\n\n\n\nThe positions in the start and stop columns in a .bed file are not both included in the interval represented. The positions correspond to the interval start:(stop - 1) as 0-based positions or (start + 1):stop in 1-based positions.\nIt doesn’t matter which one we use as long as we are consistent.\nWe will start counting from 1, just as the world’s foremost expert on counting does.\nWe wrap this conversion in a utility function to help ensure consistency.\n\n\nasrange(start, stop) = (start + one(start)):stop\n\nasrange (generic function with 1 method)\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis method definition uses the compact “one-liner” form, like the math notation f(x) = x + 1.\n\n\n\n\n\n\n\n\nNote\n\n\n\none(x) is used instead of the literal 1 in asrange to preserve the integer type (see also ?oneunit, which is slighly more general).\n\nst = Int32(2314)\ntypeof(st + 1)       # type gets promoted to Int64\n\nInt64\n\n\n\ntypeof(st + one(st)) # type not promoted\n\nInt32\n\n\n\n\n\nCreate a utility, chromodict to take a rowtable (a data structure designed to allow efficient iteration over the rows of a table) and convert it to a Dict{Symbol, Vector{UnitRange{T}}}.\n\n\nfunction chromodict(rtbl::Vector{<:NamedTuple})\n  vtype = Vector{UnitRange{typeof(first(rtbl).start)}}\n  dict = Dict{Symbol,vtype}()\n  for r in rowtable(rtbl)\n    (; chromo, start, stop) = r\n    push!(get!(dict, Symbol(chromo), vtype()), asrange(start, stop))\n  end\n  return dict\nend\ntarrngvecs = chromodict(rowtable(Arrow.Table(joinpath(datadir, \"ex-rna.arrow\"))))\nrefrngvecs = chromodict(rowtable(Arrow.Table(joinpath(datadir, \"ex-anno.arrow\"))))\n\nDict{Symbol, Vector{UnitRange{Int32}}} with 24 entries:\n  :chr21 => [5011799:5011874, 5012548:5012687, 5014386:5014471, 5016935:5017145…\n  :chr15 => [19878555:19878668, 19878831:19879004, 19881201:19881307, 19882277:…\n  :chr10 => [14497:14604, 14061:14299, 16502:16544, 14138:14299, 44712:44901, 4…\n  :chr17 => [76723:76866, 75814:75878, 71366:71556, 65830:65887, 64099:65736, 1…\n  :chr07 => [12704:12822, 26965:27199, 24314:24365, 26965:27234, 31060:31194, 2…\n  :chr14 => [16057472:16057622, 18333726:18333900, 18337973:18338078, 18338243:…\n  :chr08 => [64269:64320, 64091:64175, 72601:72673, 78905:79775, 72617:72701, 7…\n  :chr12 => [12310:12358, 12740:12824, 13102:13201, 13370:13501, 31878:32015, 2…\n  :chr18 => [11103:11595, 15617:15822, 11191:11595, 13152:13354, 15617:15928, 1…\n  :chrX  => [253743:253846, 254937:255091, 276322:276394, 281482:281684, 284167…\n  :chr13 => [18177555:18178465, 18176018:18176170, 18174442:18174512, 18174010:…\n  :chr11 => [75780:76143, 86649:87586, 125578:125927, 121258:121426, 113116:113…\n  :chr22 => [10736171:10736283, 10961283:10961338, 10959067:10959136, 10950049:…\n  :chr03 => [23757:23812, 23968:24501, 54293:54346, 53348:53692, 196607:196859,…\n  :chr19 => [70928:70976, 66346:66499, 60951:61894, 62113:66524, 70928:70951, 6…\n  :chr05 => [58198:58915, 92151:92276, 113251:113448, 139483:140716, 143047:143…\n  :chr06 => [95124:95454, 105919:106856, 144536:144885, 140211:140379, 131910:1…\n  :chr20 => [87250:87359, 96005:97094, 87710:87767, 96005:96533, 142369:142686,…\n  :chrY  => [2784749:2784853, 2786855:2787699, 2789827:2790328, 2827982:2828218…\n  :chr04 => [49096:49956, 49554:50124, 53285:53491, 59430:59556, 60058:60153, 8…\n  :chr02 => [45440:46385, 38814:41627, 42809:42952, 41220:41627, 46807:46870, 4…\n  :chr01 => [11869:12227, 12613:12721, 13221:14409, 12010:12057, 12179:12227, 1…\n  :chr09 => [12134:12190, 12291:12340, 12726:12834, 13088:13157, 13338:13487, 1…\n  :chr16 => [11555:11908, 12294:12402, 12902:14090, 11861:11908, 12294:12378, 1…\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe call get!(dict, Symbol(chromo), vtype()) in chromodict returns dict[Symbol(chromo)] or the default value, which is an empty Vector{UnitRange{T}}. For the case of the default, it also installs that key/value pair in dict.\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe use Symbols for the keys in these Dicts because they are easier to type and because symbol table lookup is very fast, although that doesn’t really matter when we only have 24 distinct keys.\n\n\n\nIn refrngvecs, each of the values, which is a Vector{UnitRange}, should be sorted by the first element of the UnitRange. For conversion to IntervalTrees below they are also required to be sorted by last if the first elements are equal.\n\n\nfor v in values(refrngvecs)\n  sort!(v, lt=((x, y) -> first(x) == first(y) ? last(x) < last(y) : first(x) < first(y)))\nend\nrefrngvecs  # note changes in refrngvecs[:chr01]\n\nDict{Symbol, Vector{UnitRange{Int32}}} with 24 entries:\n  :chr21 => [5011799:5011874, 5012548:5012687, 5014386:5014471, 5016935:5017145…\n  :chr15 => [19878555:19878668, 19878831:19879004, 19881201:19881307, 19882277:…\n  :chr10 => [14061:14299, 14138:14299, 14497:14604, 16502:16544, 44712:44901, 4…\n  :chr17 => [64099:65736, 65830:65887, 71366:71556, 75814:75878, 76723:76866, 8…\n  :chr07 => [12704:12822, 19018:19172, 19619:19895, 20834:21029, 24314:24365, 2…\n  :chr14 => [16057472:16057622, 18333726:18333900, 18333826:18333896, 18337973:…\n  :chr08 => [64091:64175, 64269:64320, 72601:72673, 72617:72701, 78905:79244, 7…\n  :chr12 => [12310:12358, 12740:12824, 13102:13201, 13370:13501, 14522:14944, 1…\n  :chr18 => [11103:11595, 11191:11595, 13152:13354, 14195:14653, 14490:14653, 1…\n  :chrX  => [253743:253846, 254937:255091, 276322:276394, 276324:276394, 276353…\n  :chr13 => [18174010:18174103, 18174442:18174512, 18176018:18176170, 18177555:…\n  :chr11 => [75780:76143, 86649:87586, 112967:113111, 113116:113174, 121258:121…\n  :chr22 => [10736171:10736283, 10939388:10939423, 10940597:10940707, 10941691:…\n  :chr03 => [23757:23812, 23968:24501, 53348:53692, 54293:54346, 195758:195914,…\n  :chr19 => [60951:61894, 62113:66524, 63821:64213, 65051:65226, 65822:66047, 6…\n  :chr05 => [58198:58915, 92151:92276, 113251:113448, 139483:140716, 140258:140…\n  :chr06 => [95124:95454, 105919:106856, 131910:132117, 140211:140379, 142272:1…\n  :chr20 => [87250:87359, 87710:87767, 96005:96533, 96005:97094, 142369:142686,…\n  :chrY  => [2784749:2784853, 2786855:2787699, 2789827:2790328, 2827982:2828218…\n  :chr04 => [49096:49956, 49554:50124, 53285:53491, 53286:53491, 53295:53491, 5…\n  :chr02 => [38814:41627, 41220:41627, 41221:41627, 42809:42952, 45440:46385, 4…\n  :chr01 => [11869:12227, 12010:12057, 12179:12227, 12613:12697, 12613:12721, 1…\n  :chr09 => [12134:12190, 12291:12340, 12726:12834, 13088:13157, 13338:13487, 1…\n  :chr16 => [11555:11908, 11861:11908, 12294:12378, 12294:12402, 12663:12733, 1…\n\n\n\nWe will use the intervals on chromsome 21 for our timing benchmarks. The target for tests of intersection with a single target interval will be the last interval on chromosome 21 in “ex-rna.arrow”.\n\n\nrefrngvec21 = refrngvecs[:chr21]\ntarrngvec21 = tarrngvecs[:chr21]\ntarget = last(tarrngvec21)\n\n31659713:31668660"
  },
  {
    "objectID": "session2b-interval-overlap.html#rangetrees",
    "href": "session2b-interval-overlap.html#rangetrees",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "RangeTrees",
    "text": "RangeTrees\n\nRangeTrees.jl provides an implementation of interval trees using the augmented binary tree formulation.\nBecause the tree is represented by its root node, there is no RangeTree type or constructor, only a RangeNode.\n\n\nrefrngtrees = Dict(k => RangeNode(v) for (k, v) in refrngvecs)\nrangetree21 = refrngtrees[:chr21]  # tree represented by its root node\n\n(36058816:36058973, 46691226)\n\n\n\n\n\n\n\n\nNote\n\n\n\nA smaller example may help to understand how this type of interval tree. Consider the first 7 UnitRanges in refrngvecs[:chr01]\n\nsmallrngvec = refrngvecs[:chr01][1:7]\n\n7-element Vector{UnitRange{Int32}}:\n 11869:12227\n 12010:12057\n 12179:12227\n 12613:12697\n 12613:12721\n 12975:13052\n 13221:13374\n\n\n\nrn = RangeNode(smallrngvec)\nprint_tree(rn)\n\n(12613:12697, 13374)\n├─ (12010:12057, 12227)\n│  ├─ (11869:12227, 12227)\n│  └─ (12179:12227, 12227)\n└─ (12975:13052, 13374)\n   ├─ (12613:12721, 12721)\n   └─ (13221:13374, 13374)\n\n\n\nThe UnitRange in the root node is the 4th out of the 7 sorted ranges from which the tree was constructed.\nEach of the nodes in the tree can have 0, 1, or 2 child nodes. Those with 0 children are called the “leaves” of the tree.\n\n\ncollect(Leaves(rn))\n\n4-element Vector{RangeNode{Int32, Int32}}:\n (11869:12227, 12227)\n (12179:12227, 12227)\n (12613:12721, 12721)\n (13221:13374, 13374)\n\n\n\nIn addition to the UnitRange it represents, each RangeNode stores maxlast, the maximum value of last(rng) for any UnitRange in the tree rooted at this node. For a leaf maxlast is simply last of its UnitRange.\nFor other nodes, maxlast can be larger than last of its UnitRange.\nIn particular, for the root node maxlast is the maximum of all the last values of the UnitRanges that generated the tree.\n\n\nmaximum(last.(smallrngvec))\n\n13374\n\n\nRangeTrees.jl defines methods for generics like children, getroot, and nodevalue from AbstractTrees.jl and these allow for many other generics to be applied to a RangeNode.\n\nchildren(rangetree21)\n\n2-element Vector{RangeNode{Int32, Int32}}:\n (25933816:25934366, 36058924)\n (43007491:43007618, 46691226)\n\n\nThe root of the tree can be obtained from any node using getroot. The combination of getroot and children allows traversal of the tree.\n\ngetroot(first(children(first(children(rangetree21))))) # get the root from its grandchild\n\n(36058816:36058973, 46691226)\n\n\n\ntreesize(rangetree21), treeheight(rangetree21), treebreadth(rangetree21)  # number of leaves\n\n(6518, 12, 2423)\n\n\n\nprint_tree(rangetree21; maxdepth = 3)\n\n(36058816:36058973, 46691226)\n├─ (25933816:25934366, 36058924)\n│  ├─ (13958116:13958185, 25928997)\n│  │  ├─ (7422603:7422701, 13954150)\n│  │  │  ⋮\n│  │  │  \n│  │  └─ (17604860:17604997, 25928997)\n│  │     ⋮\n│  │     \n│  └─ (32726772:32726917, 36058924)\n│     ├─ (29370497:29370973, 32702047)\n│     │  ⋮\n│     │  \n│     └─ (33602267:33602345, 36058924)\n│        ⋮\n│        \n└─ (43007491:43007618, 46691226)\n   ├─ (39422988:39423490, 43007515)\n   │  ├─ (37267238:37267301, 39423490)\n   │  │  ⋮\n   │  │  \n   │  └─ (41810154:41810466, 43007515)\n   │     ⋮\n   │     \n   └─ (44910284:44910415, 46691226)\n      ├─ (44133616:44134154, 44910372)\n      │  ⋮\n      │  \n      └─ (46112804:46112949, 46691226)\n         ⋮\n         \n\n\n\n\n\nEvaluating and storing maxlast in the nodes allows for overlap searchs to be truncated at nodes for which maxlast < first(target). The sorting by first allows for skipping the right subtree whenever last(target) < first(thisnode) (as in the overlaps method for Vector{UnitRange}).\nintersect and intersect! methods are already defined in RangeTrees.jl.\nCheck that their results agree with the saved result.\n\n\nsavedresult == intersect(target, rangetree21)\n\ntrue\n\n\n\nsavedresult == intersect!(result, target, rangetree21)\n\ntrue"
  },
  {
    "objectID": "session2b-interval-overlap.html#intervaltrees",
    "href": "session2b-interval-overlap.html#intervaltrees",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "IntervalTrees",
    "text": "IntervalTrees\n\nCreate a dictionary of IntervalTrees. It is somewhat tedious to get the type of the result correct and we create a function to hide the details.\n\n\nfunction toitrees(rngdict::Dict{S,Vector{UnitRange{T}}}) where {S,T}\n  return Dict(\n    k => IntervalTree{T,Interval{T}}(Interval.(v)) for (k, v) in rngdict\n  )\nend\nrefintvltrees = toitrees(refrngvecs)\nintvltree21 = refintvltrees[:chr21]\nshow(intvltree21)\n\nIntervalTree{\n\n\nInt32, Interval{Int32}}\n(5011799,5011874)\n(5012548,5012687)\n(5014386,5014471)\n⋮\n(46664295,46665117)\n(46664295,46665124)\n(46690764,46691226)\n\n\n\nCreating an intersect! method is also tedious because the package has its own Interval data type and defines intersect(itr::IntervalTree, (frst, lst)) to return an iterator of Intervals in the tree, not the intersection\n\n\nInterval(target)\n\nInterval{Int32}\n(31659713,31668660)\n\n\n\nfunction Base.intersect!(\n  res::Vector{UnitRange{T}},\n  target::AbstractUnitRange,\n  refs::IntervalTree{T},\n) where {T}\n  empty!(res)\n  firstt, lastt = first(target), last(target)\n  for isect in intersect(refs, (firstt, lastt))\n    push!(res, max(first(isect), firstt):min(last(isect), lastt))\n  end\n  return res\nend\nsavedresult == intersect!(result, target, intvltree21) # check it\n\ntrue"
  },
  {
    "objectID": "session4-exercise.html",
    "href": "session4-exercise.html",
    "title": "Hands-on exercise",
    "section": "",
    "text": "Instructions: Participants will translate their R/python script to Julia with assistance from the workshop presenters and TAs. After the 60 minutes, one or two volunteers will share their script to the group.\n\nChecklist\n\nDo you have Julia installed? If not, go to the getting started notes\nDo you have your project folder and installed dependencies? If not, go to the getting started nodes\nDo you have your data in your project folder?\nHave you selected an editor to use (VSCode, Emacs, Jupyter notebooks,…)? Check out the available options in the Julia website\n\nYou are ready to start writing Julia code! You can start with a simple .jl file, or you could try with a jupyter notebook or a .qmd file."
  },
  {
    "objectID": "session5-other-tools.html",
    "href": "session5-other-tools.html",
    "title": "Session 5: Other tools for Data Science",
    "section": "",
    "text": "Data tools with Arrow.jl and Tables.jl\nModel fitting with MixedModels.jl"
  },
  {
    "objectID": "session5-other-tools.html#communication-with-other-systems-julia-interoperability",
    "href": "session5-other-tools.html#communication-with-other-systems-julia-interoperability",
    "title": "Session 5: Other tools for Data Science",
    "section": "Communication with other systems: Julia interoperability",
    "text": "Communication with other systems: Julia interoperability\nJuliaInterop\n\nNote: Both RCall and PyCall are written 100% julia\n\nRCall\nDocumentation\nSwitching between julia and R using $:\njulia> using RCall\n\njulia> foo = 1\n1\n\nR> x <- $foo\n\nR> x\n[1] 1\nMacros @rget and @rput:\njulia> z = 1\n1\n\njulia> @rput z\n1\n\nR> z\n[1] 1\n\nR> r = 2\n\njulia> @rget r\n2.0\n\njulia> r\n2.0\nR\"\" string macro:\njulia> R\"rnorm(10)\"\nRObject{RealSxp}\n [1]  0.9515526 -2.1268329 -1.1197652 -1.3737837 -0.5308834 -0.1053615\n [7]  1.0949319 -0.8180752  0.7316163 -1.3735100\nLarge chunk of code:\njulia> y=1\n1\n\njulia> R\"\"\"\n       f<-function(x,y) x+y\n       ret<- f(1,$y)\n       \"\"\"\nRObject{RealSxp}\n[1] 2\n\nA small example from this blog\nSimulate data\njulia> using Random\n\njulia> Random.seed!(1234)\nMersenneTwister(1234)\n\njulia> X = randn(3,2)\n3×2 Matrix{Float64}:\n  0.867347  -0.902914\n -0.901744   0.864401\n -0.494479   2.21188\n\njulia> b = reshape([2.0, 3.0], 2,1)\n2×1 Matrix{Float64}:\n 2.0\n 3.0\n\njulia> y = X * b + randn(3,1)\n3×1 Matrix{Float64}:\n -0.4412351955236954\n  0.5179809120122916\n  6.149009488103242\nFit a model\njulia> @rput y\n3×1 Matrix{Float64}:\n -0.4412351955236954\n  0.5179809120122916\n  6.149009488103242\n\njulia> @rput X\n3×2 Matrix{Float64}:\n  0.867347  -0.902914\n -0.901744   0.864401\n -0.494479   2.21188\n\njulia> R\"mod <- lm(y ~ X-1)\"\nRObject{VecSxp}\n\nCall:\nlm(formula = y ~ X - 1)\n\nCoefficients:\n   X1     X2  \n2.867  3.418 \n\njulia> R\"summary(mod)\"\nRObject{VecSxp}\n\nCall:\nlm(formula = y ~ X - 1)\n\nResiduals:\n       1        2        3 \n0.158301 0.148692 0.006511 \n\nCoefficients:\n   Estimate Std. Error t value Pr(>|t|)  \nX1   2.8669     0.2566   11.17   0.0568 .\nX2   3.4180     0.1359   25.15   0.0253 *\n---\nSignif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n\nResidual standard error: 0.2173 on 1 degrees of freedom\nMultiple R-squared:  0.9988,    Adjusted R-squared:  0.9963 \nF-statistic: 404.8 on 2 and 1 DF,  p-value: 0.03512\n\njulia> R\"plot(X[,1],y)\"\n\n\n\nPyCall\nDocumentation\nNote that (@v1.8) pkg> add PyCall will use the Conda.jl package to install a minimal Python distribution (via Miniforge) that is private to Julia (not in your PATH).\nWe need to make sure that which conda points at the conda folder inside .julia, so we need to put ~/.julia/conda/3/bin early on the PATH. In Mac zsh, we need to add export PATH=~/.julia/conda/3/bin:$PATH in the ~/.zshrc file. (Those who prefer not to conda-ize their entire environment may instead choose just to link ~/.julia/conda/3/bin/{conda,jupyter,python,python3} somewhere on their existing path, such as ~/bin.)\nSimple example:\nusing PyCall\nmath = pyimport(\"math\")\nmath.sin(math.pi / 4)\npy\"...\" evaluates \"...\" as Python code:\npy\"\"\"\nimport numpy as np\n\ndef sinpi(x):\n    return np.sin(np.pi * x)\n\"\"\"\npy\"sinpi\"(1)\n\n\nMore on Julia/python connectivity\n\nThe pyjulia module allows you to call Julia directly from Python\nCheck out the packages in JuliaPy"
  },
  {
    "objectID": "session5-other-tools.html#package-system",
    "href": "session5-other-tools.html#package-system",
    "title": "Session 5: Other tools for Data Science",
    "section": "Package system",
    "text": "Package system\n\nStarting on Julia 1.6, precompilation is much faster\nMany changes under the hood that allow things to work faster and more smoothly\nA local environment can be established and preserved with Project.toml and Manifest.toml files.\nUse of Artifacts.toml allows for binary dependencies\n\n\nLandscape of Julia packages for biology\n\nBioJulia is a combination of Julia packages for biology applications.\nJulia for Biologists is an arxiv paper the features that make Julia a perfect language for bioinformatics and computational biology.\nList of useful packages by SMLP2022"
  },
  {
    "objectID": "session5-other-tools.html#plotting",
    "href": "session5-other-tools.html#plotting",
    "title": "Session 5: Other tools for Data Science",
    "section": "Plotting",
    "text": "Plotting\n\nMakie ecosystem\nPlots.jl\nOther graphics packages available in Julia"
  },
  {
    "objectID": "session5-other-tools.html#performance-tips",
    "href": "session5-other-tools.html#performance-tips",
    "title": "Session 5: Other tools for Data Science",
    "section": "Performance tips",
    "text": "Performance tips\nSee more in Julia docs\n\n@time to measure performance\njulia> x = rand(1000);\n\njulia> function sum_global()\n           s = 0.0\n           for i in x\n               s += i\n           end\n           return s\n       end;\n\njulia> @time sum_global()  ## function gets compiled\n  0.017705 seconds (15.28 k allocations: 694.484 KiB)\n496.84883432553846\n\njulia> @time sum_global()\n  0.000140 seconds (3.49 k allocations: 70.313 KiB)\n496.84883432553846\n\n\nBreak functions into multiple definitions\nThe function\nusing LinearAlgebra\n\nfunction mynorm(A)\n    if isa(A, Vector)\n        return sqrt(real(dot(A,A)))\n    elseif isa(A, Matrix)\n        return maximum(svdvals(A))\n    else\n        error(\"mynorm: invalid argument\")\n    end\nend\nshould really be written as\nnorm(x::Vector) = sqrt(real(dot(x, x)))\nnorm(A::Matrix) = maximum(svdvals(A))\nto allow the compiler to directly call the most applicable code.\n\nMultiple dispatch\n\nThe choice of which method to execute when a function is applied is called dispatch\nJulia allows the dispatch process to choose based on the number of arguments given, and on the types of all of the function’s arguments\nThis is denoted multiple dispatch\nThis is different than traditional object-oriented languages, where dispatch occurs based only on the first argument\n\njulia> f(x::Float64, y::Float64) = 2x + y\nf (generic function with 1 method)\n\njulia> f(2.0, 3.0)\n7.0\n\njulia> f(2.0, 3)\nERROR: MethodError: no method matching f(::Float64, ::Int64)\nClosest candidates are:\n  f(::Float64, !Matched::Float64) at none:1\nCompare to\njulia> f(x::Number, y::Number) = 2x + y\nf (generic function with 2 methods)\n\njulia> f(2.0, 3.0)\n7.0\n\njulia> f(2, 3.0)\n7.0\n\njulia> f(2.0, 3)\n7.0\n\njulia> f(2, 3)\n7\n\n\n\nProfiling\nRead more in Julia docs.\njulia> function myfunc()\n           A = rand(200, 200, 400)\n           maximum(A)\n       end\n\njulia> myfunc() # run once to force compilation\n\njulia> using Profile\n\njulia> @profile myfunc()\n\njulia> Profile.print()\nTo see the profiling results, there are several graphical browsers (see Julia docs).\n\n\nOther packages for performance\n\nBenchmarkTools.jl: performance tracking of Julia code\nTraceur.jl: You run your code, it tells you about any obvious performance traps"
  },
  {
    "objectID": "session5-other-tools.html#literate-programming",
    "href": "session5-other-tools.html#literate-programming",
    "title": "Session 5: Other tools for Data Science",
    "section": "Literate programming",
    "text": "Literate programming\n\nquarto.org. These notes are rendered with quarto!\nJupyter\nPluto.jl\nWeave.jl package provides “Julia markdown” and also provides support for converting between jmd files and Jupyter notebooks.\nLiterate.jl is a simple package for literate programming (i.e. programming where documentation and code are “woven” together) and can generate Markdown, plain code and Jupyter notebook output.\nDocumenter.jl is the standard tool for building webpages from Julia documentation\nBooks.jl is a package designed to offer somewhat similar functionality to the bookdown package in R."
  },
  {
    "objectID": "session6-conclusions.html",
    "href": "session6-conclusions.html",
    "title": "Session 6: Conclusions",
    "section": "",
    "text": "Julia provides many advantages to data science programmers especially those creating programs that need to be efficient and that will be shared with the scientific community\nJulia allows programmers to easily write good performant code and avoid the two language problem\n\nAmong the main Julia tools, we focused on five:\n\n\n\nArrow.jl: memory, layout, data frame, binary form. The binary form allows for cross-platform use (julia, R, python). Need to be careful going from Julia to R.\nTables.jl: generic idea of data table; row oriented (vector of named tuples) or column oriented (named tuple of vectors).\nDataFrames.jl: cheatsheet similar to tidyverse.\n\n\n\n\n\nMixedModels.jl: 100% julia package\n\n\n\n\n\nRCall.jl: 100% julia package\nPyCall.jl: 100% julia package\n\n\n\n\n\nWith Julia 1.7+, precompilation is done when the package is added\nMultiple biology-oriented packages in BioJulia\n\n\n\n\n\nPerformance tips\nProfiling\n\n\n\n\n\nMakie ecosystem\nPlots.jl\n\n\n\n\n\nquarto.org. These notes are rendered with quarto!\nJupyter\nPluto.jl"
  }
]