[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia Workshop for Data Science",
    "section": "",
    "text": "Julia has been called the programming language of the 21st century for scientific computing, data science, and machine learning. As a high-level, high-performance, dynamic language, Julia is faster than other scripting languages because of smart design decisions like type-stability through specialization via multiple-dispatch. Julia’s code can be efficient and concise, which leads to clear performance gains. In addition, Julia’s environments are fully reproducible and it is easy to express object-oriented and functional programming patterns.\nThis tutorial will provide an introduction to key Data Science tools in Julia such as data management with Arrow.jl and Tables.jl and (Generalized) linear mixed models with GLMM.jl and MixedModels.jl. Unlike widely used R packages, all packages that we will describe are written 100% in Julia thus illustrating the language’s potential to overcome the two-language problem.\nThis tutorial will appeal to anyone interested in learning more about Julia and some of the existing Julia packages that are already available for Statistics and Data Science. In addition to lectures, participants will engage in hands-on exercises. For example, participants will bring a dataset of their choice along with an existing script written in another language (R or python) that performs certain data analyses. During the tutorial, participants will translate their work to Julia in-order to compare running times and ease of programming."
  },
  {
    "objectID": "index.html#learning-objectives-for-tutorial",
    "href": "index.html#learning-objectives-for-tutorial",
    "title": "Julia Workshop for Data Science",
    "section": "Learning Objectives for Tutorial",
    "text": "Learning Objectives for Tutorial\nAt the end of the tutorial, participants will be able to:\n\nIdentify the main features that make Julia an attractive language for Data Science\nSet up a Julia environment to run their data analysis\nEfficiently handle datasets (even across different languages) through Tables.jl and Arrow.jl\nFit (generalized) linear mixed models with MixedModels.jl\nCommunicate across languages (Julia, R, python)\n\nIntended audience and level: The tutorial is intended for any data scientist with experience in R and/or python who is interested in learning the attractive features of Julia for Data Science. No knowledge of Julia is required."
  },
  {
    "objectID": "index.html#notebooks-for-the-course",
    "href": "index.html#notebooks-for-the-course",
    "title": "Julia Workshop for Data Science",
    "section": "Notebooks for the course",
    "text": "Notebooks for the course\n\nSession 0: Housekeeping\nSession 1: Get Started\nSession 2a: Data Tables and Arrow files\nSession 2b: Interval Overlap\nSession 4: Hands-on exercise\nSession 6: Conclusions"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 + 1\n\n2"
  },
  {
    "objectID": "session0-housekeeping.html",
    "href": "session0-housekeeping.html",
    "title": "Julia Workshop for Data Science",
    "section": "",
    "text": "Schedule\n\n\n\nTime\nTopic\nNotes\nPresenter\n\n\n\n\n11:00 - 11:45\nSession 1: Getting started with Julia\nNotes\nClaudia Solis-Lemus\n\n\n11:45 - 12:45\nSession 2: Data tools\n\nDoug Bates\n\n\n12:45 - 1:00\nQ&A\n\n\n\n\n1:00 - 2:00\nLunch break\n\n\n\n\n2:00 - 3:00\nSession 3: Model fitting\n\nDoug Bates\n\n\n3:00 - 3:15\nSession 4: Description of hands-on exercise\nNotes\n\n\n\n3:15 - 3:30\nCoffee break\n\n\n\n\n3:30 - 4:30\nHands-on exercise\n\nSam Ozminkowski and Bella Wu\n\n\n4:30 - 4:45\nPresentation of selected participants’ scripts\n\n\n\n\n4:45 - 5:00\nCoffee break\n\n\n\n\n5:00 - 5:30\nSession 5: Other important Data Science tools\nNotes\nClaudia Solis-Lemus\n\n\n5:30 - 6:00\nSession 6: Conclusions and questions\nNotes\nClaudia Solis-Lemus\n\n\n\n\n\nIn preparation for the workshop\nParticipants are required to follow the next steps before the day of the workshop:\n\nGit clone the workshop repository: git clone https://github.com/crsl4/julia-workshop.git\nInstall Julia. The recommended option is to use JuliaUp:\n\n\nWindows: winget install julia -s msstore\nMac and Linux: curl -fsSL https://install.julialang.org | sh\nHomebrew users: brew install juliaup\n\nAfter JuliaUp is installed, you can install different Julia versions with:\njuliaup add release  ## installs release version\njuliaup add beta     ## installs beta version\njuliaup st           ## status of julia versions installed\njuliaup default beta ## making beta version the default\n\nChoose a dataset along with a script to analyze it written in another language (R or python) as we will spend part of the workshop translating participants’ scripts to Julia."
  },
  {
    "objectID": "session1-get-started.html",
    "href": "session1-get-started.html",
    "title": "Session 1: Getting started with Julia",
    "section": "",
    "text": "“We want a language that is\n\nopen source\nwith the speed of C\nobvious, familiar mathematical notation like Matlab\nas usable for general programming as Python\nas easy for statistics as R\nas natural for string processing as Perl\nas powerful for linear algebra as Matlab\nas good at gluing programs together as the shell\ndirt simple to learn, yet keeps the most serious hackers happy”\n\n\n\n\n\nComparison with other languages: Julia touts its speed edge over Python and R\nUsed for large-scale projects like CliMA 0.1: a first milestone in the next generation of climate models\n\nClimateMachine.jl\n\nJulia adoption accelerated at a rapid pace in 2020:\n\n\n\n\n\n\n\n\nUse the REPL as a sophisticated calculator\nRealize that you are repeating many operations, so you decide to write some functions\nTo organize all your functions, you begin scripting\nYou want to share your code with others and thus, you want to write a package\nYour package is actually used by others and thus, it should be optimized and have good performance\n\nJulia offers many advantages to data science programmers: avoiding the two-language problem"
  },
  {
    "objectID": "session1-get-started.html#how-do-i-write-code",
    "href": "session1-get-started.html#how-do-i-write-code",
    "title": "Session 1: Getting started with Julia",
    "section": "How do I write code?",
    "text": "How do I write code?"
  },
  {
    "objectID": "session1-get-started.html#installing-dependencies-in-a-project-environment",
    "href": "session1-get-started.html#installing-dependencies-in-a-project-environment",
    "title": "Session 1: Getting started with Julia",
    "section": "Installing dependencies in a project environment",
    "text": "Installing dependencies in a project environment\nCreate a folder in the terminal:\nmkdir myProject\ncd myProject\nOpen Julia inside your folder, and activate your environment with:\n(@v1.8) pkg> activate .\nInstall the packages that we need for today’s workshop:\njulia> ENV[\"PYTHON\"] = \"\"\n(myproject) pkg> add PyCall\n(myproject) pkg> add IJulia\n(myproject) pkg> build IJulia\n(myproject) pkg> add MixedModels\n(myproject) pkg> add RCall\n(myproject) pkg> add Arrow\n(myproject) pkg> add DataFrames\n(myproject) pkg> add Tables\nTwo files are noteworthy:\n\nProject.toml: Defines project\nManifest.toml: Contains exact list of project dependencies\n\nshell> head Project.toml\n[deps]\nArrow = \"69666777-d1a9-59fb-9406-91d4454c9d45\"\nDataFrames = \"a93c6f00-e57d-5684-b7b6-d8193f3e46c0\"\nIJulia = \"7073ff75-c697-5162-941a-fcdaad2a7d2a\"\nMixedModels = \"ff71e718-51f3-5ec2-a782-8ffcbfa3c316\"\nPyCall = \"438e738f-606a-5dbb-bf0a-cddfbfd45ab0\"\nRCall = \"6f49c342-dc21-5d91-9882-a32aef131414\"\nTables = \"bd369af6-aec1-5ad0-b16a-f7cc5008161c\"\n\n\nshell> head Manifest.toml\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = \"1.8.0-beta3\"\nmanifest_format = \"2.0\"\nproject_hash = \"01baf737705b090869a607b779c699f83bbeb154\"\n\n[[deps.ArgTools]]\nuuid = \"0dad84c5-d112-42e6-8d28-ef12dabb789f\"\nversion = \"1.1.1\"\nLook at your Project.toml and Manifest.toml files after installation. They have all the necessary information about your session.\nThe packages have a uuid string which is the universally unique identifier. More on the Project.toml and Manifest.toml files here."
  },
  {
    "objectID": "session1-get-started.html#easy-share-with-collaborators",
    "href": "session1-get-started.html#easy-share-with-collaborators",
    "title": "Session 1: Getting started with Julia",
    "section": "Easy share with collaborators",
    "text": "Easy share with collaborators\nShare your project to colleagues. Send your entire project folder to your colleague, and all they need to do is:\njulia> cd(\"path/to/project\")\npkg> activate .\npkg> instantiate\nAll required packages and dependencies will be installed. Scripts that run in your computer will also run in their computer."
  },
  {
    "objectID": "session2a-tables-and-arrow.html",
    "href": "session2a-tables-and-arrow.html",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "",
    "text": "Code\nusing Arrow             # Arrow storage and file format\nusing CategoricalArrays # similar to the factor type in R\nusing CSV               # read/write CSV and similar formats\nusing Downloads         # file downloads\nusing DataFrames        # versatile tabular data format\nusing GZip              # utilities for compressed files\nusing RCall             # run R within Julia\nusing Tar               # tar archive utilities\n\n\nDownloads, Gzip and Tar are included just to demonstrate downloading and extracting tar files within Julia.\nYou may find it easier to simply click on the download link and extract the files by hand.\nDownloading and extracting within Julia, as shown here, has a greater chance of working across various operating systems and environments in a workshop like this.\nRCall is included to show the use of other systems running within Julia.\nYou can instead use your favorite environment, such as jupyterlab or RStudio, to run Python or R\nNote that the quarto notebooks for these notes are easily converted, e.g. quarto convert notebookname.qmd, to Jupyter notebooks."
  },
  {
    "objectID": "session2a-tables-and-arrow.html#objectives",
    "href": "session2a-tables-and-arrow.html#objectives",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Objectives",
    "text": "Objectives\n\nUse an example of computing interval overlaps to introduce Julia facilities for working with tabular data.\nIntroduce the Arrow format for tabular data and demonstrate its use in Julia, Python/Pandas and R.\nShow a naive approach to computing overlaps.\nModify the approach to use IntervalTrees.jl and multi-threading.\nRoll our own interval tree representation and use that.\n\nThis notebook covers the first two objectives."
  },
  {
    "objectID": "session2a-tables-and-arrow.html#task-and-sample-data",
    "href": "session2a-tables-and-arrow.html#task-and-sample-data",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Task and sample data",
    "text": "Task and sample data\n\nLi Heng provides benchmark code and sample data for comparing programming languages on Bioinformatics tasks in the biofast repository.\nOne of these tasks, an interval query, takes two .bed files to compare.\nOne file, ex-anno.bed, contains a reference set of intervals; the other, ex-rna.bed, contains target intervals.\nFor each target interval, determine which reference intervals overlap with it.\nIn the benchmark both the number of reference intervals that overlap with a target and the proportion of the target covered by the overlap are computed.\nNote that the calculation of the proportion of overlap must allow for overlapping intervals in the reference set, as shown in this figure"
  },
  {
    "objectID": "session2a-tables-and-arrow.html#downloading-the-sample-data",
    "href": "session2a-tables-and-arrow.html#downloading-the-sample-data",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Downloading the sample data",
    "text": "Downloading the sample data\n\nThe data sets for the benchmark are available in the compressed archive biofast-data-v1.tar.gz at biofast-data-v1.\nThe following code chunks download the tarball, if necessary, and extract the two bedfiles to a directory biofast-data-v1, if necessary. (Alternatively, you can just click on the link to the tarball in the github tag page and extract the files by hand.)\n\n\ndatadir = \"biofast-data-v1\"\ntarball = \"$datadir.tar.gz\"\nif !isfile(tarball)\n  dataurl = joinpath(\n    \"https://github.com/lh3/biofast/releases/download\",\n    datadir,\n    tarball,\n  )\n  Downloads.download(dataurl, tarball)\nend\nrun(`ls -lh $tarball`);\n\n-rw-rw-r-- 1 bates bates 541M Jun 13 10:20 biofast-data-v1.tar.gz\n\n\n\n\n\n\n\n\nNote\n\n\n\nAn expression like \"$datadir.tar.gz\" interpolates the value of datadir into the string, producing the name shown in the output.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nRedundant commas are allowed at the end of the list of arguments before the ) in a function call.\n\n\n\n\nThe .tar.gz file is about 0.5 GB. but most of that is the data for the FASTQ parsing test.\nExtract the two .bed files to be used in this example (and only if they are not present).\n\n\nisdir(datadir) || mkdir(datadir)\nbedfnms = joinpath.(datadir, [\"ex-anno.bed\", \"ex-rna.bed\"])\ntoextract = filter(!isfile, bedfnms)  # don't overwrite exisitng files\nif !isempty(toextract)\n  tmpdir = gzopen(tarball, \"r\") do io\n    Tar.extract(h -> in(h.path, toextract), io)\n  end\n  for pathnm in toextract\n    mv(joinpath(tmpdir, pathnm), pathnm; force=true)\n  end\nend\nrun(`ls -lh $datadir`);\n\ntotal 252M\n-rw-rw-r-- 1 bates bates 3.8M Jun 13 11:40 ex-anno.arrow\n-rw-r--r-- 1 bates bates  28M Jun 13 10:21 ex-anno.bed\n-rw-rw-r-- 1 bates bates  18M Jun 13 10:23 ex-rna.arrow\n-rw-r--r-- 1 bates bates 203M Jun 13 10:21 ex-rna.bed\n\n\n\n\n\n\n\n\nNote\n\n\n\nBecause of the way Quarto documents are rendered, this listing may show .arrow files that are generated later in this document.\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe expression h -> in(h.path, toextract) defines an anonymous function to be used as a predicate in Tar.extract.\n\nmethods(Tar.extract)\n\n# 4 methods for generic function extract: extract(predicate::Function, tarball::Union{Base.AbstractCmd, AbstractString, IO}) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:218  extract(predicate::Function, tarball::Union{Base.AbstractCmd, AbstractString, IO}, dir::Union{Nothing, AbstractString}; skeleton, copy_symlinks, set_permissions) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:218  extract(tarball::Union{Base.AbstractCmd, AbstractString, IO}) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:248  extract(tarball::Union{Base.AbstractCmd, AbstractString, IO}, dir::Union{Nothing, AbstractString}; skeleton, copy_symlinks, set_permissions) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:248 \n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe ‘do/end’ block is yet another way of writing an anonymous function.\n\n\n\n\n\n\n\n\nNote\n\n\n\nBecause Tar.extract is conservative about overwriting files and requires that the directory into which the files are extracted be empty, we extract to a freshly-created temporary directory then move the files to the desired location.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nIt is common for packages providing utilities to avoid name conflicts by not exporting any names from their namespace (or Module).\nThe fully qualified name, Tar.extract, can always be used - similar to Python naming conventions.\nIf a package exports a name, say foo, then after the using FooPackage directive, the unqualified name foo can be used.\nThe varinfo function provides a listing of the names exported by a Package (formally the package’s Module).\nCompare the result of varinfo(Tar) with that of varinfo(DataFrames)."
  },
  {
    "objectID": "session2a-tables-and-arrow.html#initial-processing",
    "href": "session2a-tables-and-arrow.html#initial-processing",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Initial processing",
    "text": "Initial processing\n\nThe .bed files, in this case, are simple tab-separated-value files.\nEach of the language implementations in the biofast benchmark contains code to parse lines of the .bed files producing a String and two Int32 values.\nFurthermore the results of these benchmarks are written out as very large text files. I don’t plan to read a several-million-line text file to check if a program is working properly.\nWhy go through this parsing of text files to create a numeric representation in each language?\nWriting code to parse a CSV or TSV file is tedious and error prone.\nBut skilled people have put a lot of work into creating packages to do just that.\nMore importantly they have tested, debugged, and documented their packages.\nWithin the CSV package, the CSV.read function reads and parses a file and converts it to a type specified by the second argument.\nAs is common for such functions, there are many, many optional named arguments\nWe read ex-anno.bed and create a DataFrame as\n\n\nannodf = CSV.read(\n  joinpath(datadir, \"ex-anno.bed\"),\n  DataFrame;\n  delim='\\t',\n  types=[String, Int32, Int32],\n  header=[\"chromo\", \"start\", \"stop\"],\n)\n\n\n1,193,657 rows × 3 columnschromostartstopStringInt32Int321chr111868122272chr112612127213chr113220144094chr112009120575chr112178122276chr112612126977chr112974130528chr113220133749chr1134521367010chr1295332957011chr1247372489112chr1182671836613chr1179141806114chr1176051774215chr1172321736816chr1168571705517chr1166061676518chr1157951594719chr1150041503820chr1144031450121chr1173681743622chr1295533003923chr1305633066724chr1309753109725chr1302663066726chr1309753110927chr1303653050328chr1357203608129chr1352763548130chr13455335174⋮⋮⋮⋮\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nPositional arguments must come before named arguments.\nOptionally, the comma after the last positional argument can be replace by a semicolon, as shown above.\n\n\n\n\nIt turns out that both of the .bed files contain many duplicate rows. Use unique! to eliminate the duplicates.\n\n\n\n\n\n\n\nNote\n\n\n\nA function’s name ending in ! is a hint that it is a mutating function, which can modify one or more of its arguments.\n\n\n\nAs row order is not important, we also sort! the DataFrame, which has the effect of sorting the intervals within a chromosome by start position.\nBefore sorting I will change strings like \"chr1\" to \"chr01\" so that sorting by chromo is equivalent to sorting by chromosome number.\nThe replace! generic takes the object to modify and one or more pairs of values of the form from => to\nWe generate a vector of pairs of strings for replacement then “splat” them into a call to replace\n\n\nreplacements =  [\"chr$i\" => \"chr0$i\" for i in 1:9]\n\n9-element Vector{Pair{String, String}}:\n \"chr1\" => \"chr01\"\n \"chr2\" => \"chr02\"\n \"chr3\" => \"chr03\"\n \"chr4\" => \"chr04\"\n \"chr5\" => \"chr05\"\n \"chr6\" => \"chr06\"\n \"chr7\" => \"chr07\"\n \"chr8\" => \"chr08\"\n \"chr9\" => \"chr09\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe expression in the right is called a “comprehension”. I think of it as an inside-out loop.\n\n\n\nshow(unique(replace!(annodf.chromo, replacements...)))\n\n[\"chr01\", \"chr02\", \"chr03\", \"chr04\", \"chr05\", \"chr06\", \"chr07\", \"chrX\", \"chr08\", \"chr09\", \"chr11\", \"chr10\", \"chr12\", \"chr13\", \"chr14\", \"chr15\", \"chr16\", \"chr17\", \"chr18\", \"chr20\", \"chr19\", \"chrY\", \"chr22\", \"chr21\"]\n\n\n\nsort!(unique!(annodf))\nannodf.chromo = categorical(annodf.chromo; ordered=true)\nannodf\n\n\n573,806 rows × 3 columnschromostartstopCat…Int32Int321chr0111868122272chr0112009120573chr0112178122274chr0112612126975chr0112612127216chr0112974130527chr0113220133748chr0113220144099chr01134521367010chr01144031450111chr01150041503812chr01157951594713chr01166061676514chr01168571705515chr01172321736816chr01173681743617chr01176051774218chr01179141806119chr01182671836620chr01247372489121chr01295332957022chr01295533003923chr01302663066724chr01303653050325chr01305633066726chr01309753109727chr01309753110928chr01345533517429chr01352443548130chr013527635481⋮⋮⋮⋮"
  },
  {
    "objectID": "session2a-tables-and-arrow.html#arrow-file-format",
    "href": "session2a-tables-and-arrow.html#arrow-file-format",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Arrow file format",
    "text": "Arrow file format\n\nThe Arrow project defines a memory and file format for storing and manipulating column-oriented, static, tables (i.e. like data frames in R, Python/Pandas, and Julia)\nEither ‘lz4’ or ‘zstd’ compression can be used when creating an Arrow file.\nMetadata on the names and types of columns is automatically stored. Additional column or table metadata can be specified.\n\n\nArrow.write(\n  \"./biofast-data-v1/ex-anno.arrow\",\n  annodf;\n  compress=:lz4,\n  metadata=[\n    \"url\" =>\n    \"https://github.com/lh3/biofast/releases/tag/biofast-data-v1\",\n  ],\n)\n\n\"./biofast-data-v1/ex-anno.arrow\"\n\n\n\nbed2arrow encapsulates reading the .bed file, replacing the strings in the chromo column, reducing the data frame to unique, sorted rows, and writing the Arrow file.\nNamed arguments with defaults are used to configure the “usual” call but allow for variations.\nThe Boolean overwrite named argument, which defaults to false, controls overwriting of existing files.\n\n\nmetadata = [\"url\" => \"https://github.com/lh3/biofast/releases/tag/biofast-data-v1\",]\nfunction bed2arrow(\n  fnroot::AbstractString;\n  datadir=datadir,\n  delim='\\t',\n  header=[:chromo, :start, :stop],\n  types=[String, Int32, Int32],\n  compress=:lz4,\n  metadata=metadata,\n  replacements=replacements,\n  overwrite::Bool=false,\n)\n  bednm = joinpath(datadir, \"$fnroot.bed\")\n  arrownm = joinpath(datadir, \"$fnroot.arrow\")\n  if overwrite || !isfile(arrownm)\n    df = CSV.read(bednm, DataFrame; header, delim, types)\n    replace!(df.chromo, replacements...)\n    sort!(unique!(df))\n    df.chromo = categorical(df.chromo; ordered=true)\n    Arrow.write(arrownm, df; compress, metadata)\n  end\n  return arrownm\nend\nrnaarrownm = bed2arrow(\"ex-rna\")\n\n\"biofast-data-v1/ex-rna.arrow\"\n\n\n\nrun(`ls -lh $datadir`);\n\ntotal 252M\n-rw-rw-r-- 1 bates bates 3.8M Jun 13 12:02 ex-anno.arrow\n-rw-r--r-- 1 bates bates  28M Jun 13 10:21 ex-anno.bed\n-rw-rw-r-- 1 bates bates  18M Jun 13 10:23 ex-rna.arrow\n-rw-r--r-- 1 bates bates 203M Jun 13 10:21 ex-rna.bed\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the calls to CSV.read and Arrow.write, the semicolon after the positional arguments followed by argument names only indicates that the value passed for the named argument is the object of the same name in the current namespace. That is, Arrow.write(arrownm, df; compress, metadata) is equivalent to Arrow.write(arrownm, df; compress=compress, metadata=metadata)."
  },
  {
    "objectID": "session2a-tables-and-arrow.html#reading-arrow-files-in-julia",
    "href": "session2a-tables-and-arrow.html#reading-arrow-files-in-julia",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Reading Arrow files in Julia",
    "text": "Reading Arrow files in Julia\n\nannotbl = Arrow.Table(\"./biofast-data-v1/ex-anno.arrow\")\n\nArrow.Table with 573806 rows, 3 columns, and schema:\n :chromo  String\n :start   Int32\n :stop    Int32\n\nwith metadata given by a Base.ImmutableDict{String, String} with 1 entry:\n  \"url\" => \"https://github.com/lh3/biofast/releases/tag/biofast-data-v1\"\n\n\n\nAlthough the schema describes the chromo column as Strings the values are dictionary encoded such that each value is represented by one byte.\n\n\ntypeof(annotbl.chromo)\n\nArrow.DictEncoded{String, Int8, Arrow.List{String, Int32, Vector{UInt8}}}\n\n\n\nrnatbl = Arrow.Table(rnaarrownm)\n\nArrow.Table with 4685080 rows, 3 columns, and schema:\n :chromo  String\n :start   Int32\n :stop    Int32\n\nwith metadata given by a Base.ImmutableDict{String, String} with 1 entry:\n  \"url\" => \"https://github.com/lh3/biofast/releases/tag/biofast-data-v1\"\n\n\n\nWe can use operations like split-apply-combine on these tables to summarize properties\n\n\nannogdf = groupby(DataFrame(annotbl), :chromo)\nrnagdf = groupby(DataFrame(rnatbl), :chromo)\ninnerjoin(\n  combine(rnagdf, nrow => :nrna),\n  combine(annogdf, nrow => :nanno);\n  on=:chromo,\n)  \n\n\n24 rows × 3 columnschromonrnanannoStringInt64Int641chr01453114527892chr02298278425633chr03251858347694chr04132781225005chr05225898260856chr06307747249357chr07217038276138chr08141205216039chr091651812018910chr101622562006111chr112865843402112chr122920023352413chr1376779946414chr141714021999515chr151717362218716chr161925952827617chr172883483588818chr18604291017919chr193447753545120chr201099791238721chr2151720651822chr221329561272423chrX1503301761824chrY892467"
  },
  {
    "objectID": "session2a-tables-and-arrow.html#reading-arrow-files-in-r",
    "href": "session2a-tables-and-arrow.html#reading-arrow-files-in-r",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Reading Arrow files in R",
    "text": "Reading Arrow files in R\n\nIn R (and in Python) the Arrow file format is confounded with an earlier file format called Feather and referred to as Feather V2.\nIn R the arrow::read_feather function returns a tibble. In an R session it looks like\n\n> library(tibble)\n> arrow::read_feather(\"./biofast-data-v1/ex-rna.arrow\")\n# A tibble: 4,685,080 × 3\n   chromo start  stop\n   <fct>  <int> <int>\n 1 chr01  14354 24892\n 2 chr01  14359 24855\n 3 chr01  14361 14672\n 4 chr01  14361 16878\n 5 chr01  14366 24894\n 6 chr01  14370 14989\n 7 chr01  14396 24894\n 8 chr01  14397 17733\n 9 chr01  14398 24894\n10 chr01  14399 15977\n# … with 4,685,070 more rows\n\nThe RCall package in Julia allows for running an R process within a Julia session.\nOne way of executing R code with RCall is to prepend R to a string. This causes the string to be evaluated in R.\n$-interpolation in the string causes a Julia object to be copied into the R environment and its name in R interpolated.\n\n\nR\"\"\"\nlibrary(tibble)\nglimpse(rnatbl <- arrow::read_feather($rnaarrownm))\n\"\"\";\n\nRows: 4,685,080\nColumns: 3\n$ chromo <fct> chr01, chr01, chr01, chr01, chr01, chr01, chr01, chr01, chr01, …\n$ start  <int> 14354, 14359, 14361, 14361, 14366, 14370, 14396, 14397, 14398, …\n$ stop   <int> 24892, 24855, 14672, 16878, 24894, 14989, 24894, 17733, 24894, …"
  },
  {
    "objectID": "session2a-tables-and-arrow.html#reading-arrow-files-in-python",
    "href": "session2a-tables-and-arrow.html#reading-arrow-files-in-python",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Reading Arrow files in Python",
    "text": "Reading Arrow files in Python\n\nThe pyarrow package includes pyarrow.feather. Its use in a Python session looks like\n\n>>> import pyarrow.feather as fea\n>>> fea.read_table('./biofast-data-v1/ex-rna.arrow')\npyarrow.Table\nchromo: dictionary<values=string, indices=int8, ordered=0> not null\nstart: int32 not null\nstop: int32 not null\n----\nchromo: [  -- dictionary:\n[\"chr01\",\"chr02\",\"chr03\",\"chr04\",\"chr05\",...,\"chr20\",\"chr21\",\"chr22\",\"chrX\",\"chrY\"]  -- indices:\n[0,0,0,0,0,...,23,23,23,23,23]]\nstart: [[14354,14359,14361,14361,14366,...,18992169,18992297,24362035,24362037,25307904]]\nstop: [[24892,24855,14672,16878,24894,...,18992298,18992676,24362135,24362201,25308109]]\n>>> fea.read_feather('./biofast-data-v1/ex-rna.arrow')\n        chromo     start      stop\n0        chr01     14354     24892\n1        chr01     14359     24855\n2        chr01     14361     14672\n3        chr01     14361     16878\n4        chr01     14366     24894\n...        ...       ...       ...\n4685075   chrY  18992169  18992298\n4685076   chrY  18992297  18992676\n4685077   chrY  24362035  24362135\n4685078   chrY  24362037  24362201\n4685079   chrY  25307904  25308109\n\n[4685080 rows x 3 columns]\n\nread_table returns a Table object, read_feather returns a Pandas dataframe.\nThe PyCall package for Julia starts a Python process and allows communication with it, including data transfer.\nI use this instead of the Python REPL when working with both Julia and Python.\nConfiguring Python, Conda, pyarrow, pandas, and PyCall across platforms is sufficiently complicated to almost surely cause failures for some workshop participants. Instead of evaluating this code chunk we quote the results.\n\njulia> using PyCall\n\njulia> fea = pyimport(\"pyarrow.feather\")\n\njulia> fea.read_table(rnaarrownm)\nPyObject pyarrow.Table\nchromo: dictionary<values=string, indices=int8, ordered=0> not null\nstart: int32 not null\nstop: int32 not null\n----\nchromo: [  -- dictionary:\n[\"chr01\",\"chr02\",\"chr03\",\"chr04\",\"chr05\",...,\"chr20\",\"chr21\",\"chr22\",\"chrX\",\"chrY\"]  -- indices:\n[0,0,0,0,0,...,23,23,23,23,23]]\nstart: [[14354,14359,14361,14361,14366,...,18992169,18992297,24362035,24362037,25307904]]\nstop: [[24892,24855,14672,16878,24894,...,18992298,18992676,24362135,24362201,25308109]]"
  },
  {
    "objectID": "session2a-tables-and-arrow.html#conclusions",
    "href": "session2a-tables-and-arrow.html#conclusions",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Conclusions",
    "text": "Conclusions\n\nJulia provides an impressive array of tools for Bioinformatics and similar tasks\nWe have shown the use of Arrow.jl, CategoricalArrays.jl CSV.jl, and DataFrames for data input, storage and manipulation.\nAlthough not shown here DataFrameMacros.jl (or DataFramesMeta.jl) and Chain.jl are worth considering for more sophisticated work with DataFrames.\nA general framework for working with tabular data is provided in Tables.jl (not shown here).\nWe have shown the use of PyCall.jl and RCall.jl for running and communicating with other language systems within Julia.\nWe have shown the use of utility packages Downloads.jl, GZip.jl and Tar.jl for scripting, say within Quarto documents like these.\nTake a moment to look at the repositories for some of these Julia packages. Most (all?) of them are 100% Julia code."
  },
  {
    "objectID": "session2a-tables-and-arrow.html#version-information",
    "href": "session2a-tables-and-arrow.html#version-information",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Version information",
    "text": "Version information\n\nversioninfo()\n\nJulia Version 1.8.0-rc1\nCommit 6368fdc656 (2022-05-27 18:33 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: 4 × Intel(R) Core(TM) i5-7500 CPU @ 3.40GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, skylake)\n  Threads: 4 on 4 virtual cores"
  },
  {
    "objectID": "session2b-interval-overlap.html",
    "href": "session2b-interval-overlap.html",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "",
    "text": "Load packages to be used"
  },
  {
    "objectID": "session2b-interval-overlap.html#objectives",
    "href": "session2b-interval-overlap.html#objectives",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Objectives",
    "text": "Objectives\n\nSet up the data structures for the reference intervals and the targets\nUse methods and datatypes from IntervalTrees.jl to determine the coverage.\nPresent alternative approaches."
  },
  {
    "objectID": "session2b-interval-overlap.html#overview",
    "href": "session2b-interval-overlap.html#overview",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Overview",
    "text": "Overview\n\nConvert the reference intervals to a dictionary of ranges\n\nThe reference (i.e. anno) intervals are converted to a GroupedDataFrame then converted to a Dict{Symbol, Vector{UnitRange}}.\n\n\n\n\n\n\n\nNote\n\n\n\nWe could use the original character strings in the chromo column as the keys in this Dict. There are some advantages to using symbols - for one, symbols are easier to type. The important advantages are smaller memory footprint and faster lookup.\n\n\n\nThe intervals should be sorted by increasing first element. We know this is true for our tables but it is safest to sort them. (“Trust but verify” is the data scientist’s motto.). An in-place sort! is very fast if the elements of the container are already sorted.\nThe interval represented on a row of a .bed file is, in 0-based positions, start:(stop - 1).\nWe could equally well use 1-based positions (start + 1):stop as long as we are consistent.\nThere is a small advantage in incrementing start rather than decrementing stop if the integer type happens to be unsigned.\nWe define methods for an asrange function that returns the range from a start, stop pair.\none(x) is used instead of the literal 1 to preserve types (see also ?oneunit, which is slighly more general).\nMethods for first and last return the inclusive end points of a UnitRange.\n\n\n# utility functions\nasrange(start, stop) = (start + one(start)):stop\ndatatable(fnroot::AbstractString) = DataFrame(Arrow.Table(joinpath(datadir, \"$fnroot.arrow\")))\nsortedranges(adf::AbstractDataFrame) = sort!(asrange.(adf.start, adf.stop); by=first)\n\nsortedranges (generic function with 1 method)\n\n\n\n\n\n\n\n\nNote\n\n\n\nThese use the compact “one-liner” form for defining a function.\n\n\n\nNow create the dictionary (i.e. key => value pairs)\n\n\nrefranges = let\n  gdf = groupby(datatable(\"ex-anno\"), :chromo)\n  Dict(Symbol(k.chromo) => sortedranges(gdf[k]) for k in keys(gdf))\nend\n\nDict{Symbol, Vector{UnitRange{Int32}}} with 24 entries:\n  :chr21 => [5011799:5011874, 5012548:5012687, 5014386:5014471, 5016935:5017145…\n  :chr15 => [19878555:19878668, 19878831:19879004, 19881201:19881307, 19882277:…\n  :chr10 => [14061:14299, 14138:14299, 14497:14604, 16502:16544, 44712:44901, 4…\n  :chr17 => [64099:65736, 65830:65887, 71366:71556, 75814:75878, 76723:76866, 8…\n  :chr07 => [12704:12822, 19018:19172, 19619:19895, 20834:21029, 24314:24365, 2…\n  :chr14 => [16057472:16057622, 18333726:18333900, 18333826:18333896, 18337973:…\n  :chr08 => [64091:64175, 64269:64320, 72601:72673, 72617:72701, 78905:79244, 7…\n  :chr12 => [12310:12358, 12740:12824, 13102:13201, 13370:13501, 14522:14944, 1…\n  :chr18 => [11103:11595, 11191:11595, 13152:13354, 14195:14653, 14490:14653, 1…\n  :chrX  => [253743:253846, 254937:255091, 276322:276394, 276324:276394, 276353…\n  :chr13 => [18174010:18174103, 18174442:18174512, 18176018:18176170, 18177555:…\n  :chr11 => [75780:76143, 86649:87586, 112967:113111, 113116:113174, 121258:121…\n  :chr22 => [10736171:10736283, 10939388:10939423, 10940597:10940707, 10941691:…\n  :chr03 => [23757:23812, 23968:24501, 53348:53692, 54293:54346, 195758:195914,…\n  :chr19 => [60951:61894, 62113:66524, 63821:64213, 65051:65226, 65822:66047, 6…\n  :chr05 => [58198:58915, 92151:92276, 113251:113448, 139483:140716, 140258:140…\n  :chr06 => [95124:95454, 105919:106856, 131910:132117, 140211:140379, 142272:1…\n  :chr20 => [87250:87359, 87710:87767, 96005:96533, 96005:97094, 142369:142686,…\n  :chrY  => [2784749:2784853, 2786855:2787699, 2789827:2790328, 2827982:2828218…\n  :chr04 => [49096:49956, 49554:50124, 53285:53491, 53286:53491, 53295:53491, 5…\n  :chr02 => [38814:41627, 41220:41627, 41221:41627, 42809:42952, 45440:46385, 4…\n  :chr01 => [11869:12227, 12010:12057, 12179:12227, 12613:12697, 12613:12721, 1…\n  :chr09 => [12134:12190, 12291:12340, 12726:12834, 13088:13157, 13338:13487, 1…\n  :chr16 => [11555:11908, 11861:11908, 12294:12378, 12294:12402, 12663:12733, 1…\n\n\n\n\n\n\n\n\nNote\n\n\n\nA let-block, as used here, creates a temporary namespace. The assignment to gdf is local to the let-block and does not clutter up the global namespace.\n\n\n\nTo use the methods in IntervalTrees.jl we create a similar dictionary with IntervalTree{T, Interval{T}} values.\n\n\nfunction toitrees(rngdict::Dict{S, Vector{UnitRange{T}}}) where {S,T}\n  return Dict(k => IntervalTree{T, Interval{T}}(Interval.(v)) for (k,v) in rngdict)\nend\nrefitrees = toitrees(refranges)\ntypeof(refitrees)\n\nDict{Symbol, IntervalTree{Int32, Interval{Int32}}}\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe call Interval.(v) is an example of dot broadcasting\n\n\n\nshow(refitrees[:chr21])\n\nIntervalTree{\n\n\nInt32, Interval{Int32}}\n(5011799,5011874)\n(5012548,5012687)\n(5014386,5014471)\n⋮\n(46664295,46665117)\n(46664295,46665124)\n(46690764,46691226)\n\n\n\n\nMethods for a single overlap evalation\n\nThe actual comparisons are performed in methods for overlap for a UnitRange and one of the value types in these dictionaries.\nAn overlap method returns two integer values, the number of intervals in the reference set that overlap the target and the coverage, which is the number of elements in the target that are also in one or more of the reference intervals.\nMethods for overlap! do the same thing but have an additional argument which is a vector used to accumulate the overlapping intervals.\n\n\n\nIterating over the targets\n\nThe table of targets is converted to a rowtable for iterating over rows.\n\n\nrnadf = datatable(\"ex-rna\")\nrnartbl = rowtable(\n  (;\n    chromo = Symbol.(rnadf.chromo), # to match the keys in Dict's just created\n    range = asrange.(rnadf.start, rnadf.stop),\n  )\n)\n\n4685080-element Vector{NamedTuple{(:chromo, :range), Tuple{Symbol, UnitRange{Int32}}}}:\n (chromo = :chr01, range = 14355:24892)\n (chromo = :chr01, range = 14360:24855)\n (chromo = :chr01, range = 14362:14672)\n (chromo = :chr01, range = 14362:16878)\n (chromo = :chr01, range = 14367:24894)\n (chromo = :chr01, range = 14371:14989)\n (chromo = :chr01, range = 14397:24894)\n (chromo = :chr01, range = 14398:17733)\n (chromo = :chr01, range = 14399:24894)\n (chromo = :chr01, range = 14400:15977)\n (chromo = :chr01, range = 14400:17368)\n (chromo = :chr01, range = 14400:18421)\n (chromo = :chr01, range = 14400:19224)\n ⋮\n (chromo = :chrY, range = 13704321:13705703)\n (chromo = :chrY, range = 16707280:16707526)\n (chromo = :chrY, range = 18992104:18992424)\n (chromo = :chrY, range = 18992104:18992705)\n (chromo = :chrY, range = 18992107:18992666)\n (chromo = :chrY, range = 18992128:18992658)\n (chromo = :chrY, range = 18992142:18992375)\n (chromo = :chrY, range = 18992170:18992298)\n (chromo = :chrY, range = 18992298:18992676)\n (chromo = :chrY, range = 24362036:24362135)\n (chromo = :chrY, range = 24362038:24362201)\n (chromo = :chrY, range = 25307905:25308109)\n\n\n\nThe NamedTuples in a rowtable are immutable, which means the vector can be stored compactly.\nMethods for overlaps take such a rowtable and one of the dictionary types, producing a DataFrame with two columns named nover and coverage.\n\n\nfunction overlaps(targets::AbstractVector{<:NamedTuple}, refs::Dict)\n  nover = similar(targets, (length(targets) ≤ typemax(Int32) ? Int32 : Int64))\n  coverage = similar(targets, typeof(first(first(targets).range)))\n  @inbounds Threads.@threads for i in eachindex(targets)\n    tup = targets[i]\n    nover[i], coverage[i] = overlap(tup.range, refs[tup.chromo])\n  end\n  return DataFrame((; nover, coverage))\nend\n\noverlaps (generic function with 1 method)\n\n\n\nWe have formulated the for loop as a simple loop over an integer index. When Julia is running multi-threaded the Threads.@threads macro will partition the indices over the threads."
  },
  {
    "objectID": "session2b-interval-overlap.html#cut-to-the-chase",
    "href": "session2b-interval-overlap.html#cut-to-the-chase",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Cut to the chase",
    "text": "Cut to the chase\n\nOne of the fastest overlap methods is the one for an IntervalTree, shown here and explained below.\n\n\nfunction overlap(target::UnitRange{T}, reference::IntervalTree{T}) where {T}\n  n = 0\n  coverage = 0\n  goalposts = target\n  rightpost = last(goalposts)\n  for ivl in intersect(reference, (first(target), last(target)))\n    n += 1\n    coverage += length(intersect(goalposts, first(ivl):last(ivl)))\n    goalposts = (last(ivl) + one(T)):rightpost\n  end\n  return n, coverage\nend\n\noverlap (generic function with 1 method)\n\n\n\nFor testing and preliminary timing create a sample of 20000 rows of rnartbl\n\n\nrnasamp = rnartbl[sort!(rand(Random.seed!(1234321), eachindex(rnartbl), 20_000))]\n\n20000-element Vector{NamedTuple{(:chromo, :range), Tuple{Symbol, UnitRange{Int32}}}}:\n (chromo = :chr01, range = 184958:186721)\n (chromo = :chr01, range = 630762:630964)\n (chromo = :chr01, range = 630763:631068)\n (chromo = :chr01, range = 630764:630885)\n (chromo = :chr01, range = 630861:631053)\n (chromo = :chr01, range = 631082:632570)\n (chromo = :chr01, range = 631592:632148)\n (chromo = :chr01, range = 632068:632649)\n (chromo = :chr01, range = 632131:632690)\n (chromo = :chr01, range = 632263:632688)\n (chromo = :chr01, range = 632278:632684)\n (chromo = :chr01, range = 632323:632604)\n (chromo = :chr01, range = 632447:632690)\n ⋮\n (chromo = :chrX, range = 154886272:154888061)\n (chromo = :chrX, range = 154886368:154888059)\n (chromo = :chrX, range = 155033401:155055048)\n (chromo = :chrX, range = 155220182:155239812)\n (chromo = :chrX, range = 155239029:155239810)\n (chromo = :chrX, range = 155276209:155276846)\n (chromo = :chrX, range = 155457410:155458598)\n (chromo = :chrX, range = 155881364:155943766)\n (chromo = :chrX, range = 155881369:155943675)\n (chromo = :chrX, range = 155881423:155943766)\n (chromo = :chrX, range = 155942223:155943763)\n (chromo = :chrX, range = 155942896:155943763)\n\n\n\nsampleresult = overlaps(rnasamp, refitrees)\n\n\n20,000 rows × 2 columnsnovercoverageInt32Int3213356200300400500621489715578254992486102354112339122282131170144168015257916353982178787184261194580204534214596224602233557243515253453263278273227283205294325303282⋮⋮⋮\n\n\n\n@benchmark overlaps($rnasamp, $refitrees)\n\n\nBenchmarkTools.Trial: 1108 samples with 1 evaluation.\n Range (min … max):  4.016 ms … 41.874 ms  ┊ GC (min … max): 0.00% … 89.18%\n Time  (median):     4.289 ms              ┊ GC (median):    0.00%\n Time  (mean ± σ):   4.504 ms ±  2.535 ms  ┊ GC (mean ± σ):  4.38% ±  6.91%\n       █▆                                                     \n  ▃▆▅▄▅███▄▂▃▂▂▂▂▂▂▂▂▂▁▁▁▂▁▁▁▁▁▁▁▂▂▁▁▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▂▁▁▁▁▂▂ ▂\n  4.02 ms        Histogram: frequency by time        6.78 ms <\n Memory estimate: 1.83 MiB, allocs estimate: 60056.\n\n\n\nThis test run is sufficiently fast that we can\n\n@time result = overlaps(rnartbl, refitrees)\n\n  0.939353 seconds (14.06 M allocations: 429.201 MiB, 6.08% gc time, 0.93% compilation time)\n\n\n\n4,685,080 rows × 2 columnsnovercoverageInt32Int3211214312121390321404650651214196213171213898997991213871042881177811211123213111232141112321511123216121346171213821812138619121386201213862176240622212138523121385241112302512138426121383271213832875237402929830298⋮⋮⋮"
  },
  {
    "objectID": "session2b-interval-overlap.html#alternative-approaches",
    "href": "session2b-interval-overlap.html#alternative-approaches",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Alternative approaches",
    "text": "Alternative approaches\n\nA naive approach is to intersect target with each of the ranges in the reference vector, count the non-empty intersections and use a BitSet to keep track of the coverage.\nBecause the reference vector is sorted by first position we can stop as soon as the first position of a reference interval exceeds the last position of the target.\n\n\nfunction overlap(target::UnitRange{T}, reference::Vector{UnitRange{T}}) where {T}\n  lt = last(target)\n  n = 0\n  bs = BitSet()\n  for ref in reference\n    isect = intersect(ref, target)\n    if !isempty(isect)\n      n += 1     # increment the count of intersecting intervals\n      union!(bs, isect)\n    end\n    first(ref) ≤ lt || break\n  end\n  return n, length(bs)\nend\n\noverlap (generic function with 2 methods)\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nWhile creating these notes we discovered a bug in the union! method called here.\nThere was a PR to fix it the next morning.\nVersions of Julia prior to 1.8.0-rc2 can (and probably will) return incorrect values of coverage.\nReplacing union!(bs, isect) by union!(bs, BitSet(isect)) avoids this “infelicity” at the expense of more memory usage and compute time.\nWe present a better alternative below.\n\n\n\n\n@benchmark overlaps($rnasamp, refranges)\n\n\nBenchmarkTools.Trial: 26 samples with 1 evaluation.\n Range (min … max):  193.882 ms … 212.149 ms  ┊ GC (min … max): 0.00% … 8.18%\n Time  (median):     195.411 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   198.284 ms ±   6.482 ms  ┊ GC (mean ± σ):  1.54% ± 3.03%\n  ▄█▁ █▁▁ ▁                                                   ▁  \n  ███▁███▆█▁▁▁▁▁▆▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▆▆▆▁▁▁█ ▁\n  194 ms           Histogram: frequency by time          212 ms <\n Memory estimate: 93.98 MiB, allocs estimate: 93308."
  },
  {
    "objectID": "session2b-interval-overlap.html#moving-the-goalposts",
    "href": "session2b-interval-overlap.html#moving-the-goalposts",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Moving the goalposts",
    "text": "Moving the goalposts\n\nWe can take advantage of the intersecting intervals being produced in sorted order when computing the coverage.\nThe idea is to “keep moving the goalposts”. When evaluating the coverage add the length of the current reference interval’s intersection with only the part to the right of what has already been covered.\n\n\nfunction overlap(target::UnitRange{T}, reference::Vector{UnitRange{T}}) where {T}\n  n = 0\n  coverage = 0\n  goalposts = target\n  rightpost = last(goalposts)\n  for ref in reference\n    isect = intersect(target, ref)\n    if !isempty(isect)\n      n += 1\n      coverage += length(intersect(goalposts, isect))\n      goalposts = (last(isect) + one(T)):rightpost\n    end\n    first(ref) ≤ rightpost || break\n  end\n  return n, coverage\nend\nsampleresult == overlaps(rnasamp, refranges)  # check the we reproduce earlier results\n\ntrue\n\n\n\n@benchmark overlaps(targets, refs) setup=(targets = rnasamp; refs = refranges)\n\n\nBenchmarkTools.Trial: 46 samples with 1 evaluation.\n Range (min … max):  108.627 ms … 110.791 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     108.910 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   108.985 ms ± 394.650 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n   █  ▁▁▃▁▁▆ ▁                                                   \n  ▇█▇▄██████▇█▇▄▁▁▁▄▁▁▁▁▁▄▁▁▁▁▁▁▁▁▇▁▁▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▄ ▁\n  109 ms           Histogram: frequency by time          111 ms <\n Memory estimate: 316.41 KiB, allocs estimate: 59."
  },
  {
    "objectID": "session2b-interval-overlap.html#rolling-our-own-interval-tree",
    "href": "session2b-interval-overlap.html#rolling-our-own-interval-tree",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Rolling our own interval tree",
    "text": "Rolling our own interval tree\n\nRangeTrees.jl is a bespoke implementation of interval trees using the “augmented” balanced binary tree form.\n\n\nrefrangetrees = Dict(k => RangeTree(v) for (k, v) in refranges)\n\nDict{Symbol, RangeTree{Int32}} with 24 entries:\n  :chr21 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(5011799:5011874,…\n  :chr15 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(19878555:1987866…\n  :chr10 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(14061:14299, 0, …\n  :chr17 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(64099:65736, 0, …\n  :chr07 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(12704:12822, 0, …\n  :chr14 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(16057472:1605762…\n  :chr08 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(64091:64175, 0, …\n  :chr12 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(12310:12358, 0, …\n  :chr18 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(11103:11595, 0, …\n  :chrX  => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(253743:253846, 0…\n  :chr13 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(18174010:1817410…\n  :chr11 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(75780:76143, 0, …\n  :chr22 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(10736171:1073628…\n  :chr03 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(23757:23812, 0, …\n  :chr19 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(60951:61894, 0, …\n  :chr05 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(58198:58915, 0, …\n  :chr06 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(95124:95454, 0, …\n  :chr20 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(87250:87359, 0, …\n  :chrY  => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(2784749:2784853,…\n  :chr04 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(49096:49956, 0, …\n  :chr02 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(38814:41627, 0, …\n  :chr01 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(11869:12227, 0, …\n  :chr09 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(12134:12190, 0, …\n  :chr16 => RangeTree{Int32}(RangeNode{Int32}[RangeNode{Int32}(11555:11908, 0, …\n\n\nThe package defines methods for both intersect and intersect! of a UnitRange and a RangeTree. In the mutating method a vector to hold the results is passed as the first argument, thereby eliminating the storage allocation for the result.\n\nrng = first(rnartbl).range\nintersect(rng, refrangetrees[:chr01])\n\n12-element Vector{UnitRange{Int32}}:\n 14355:14409\n 14404:14501\n 15005:15038\n 15796:15947\n 16607:16765\n 16858:17055\n 17233:17368\n 17369:17436\n 17606:17742\n 17915:18061\n 18268:18366\n 24738:24891\n\n\n\nisects = typeof(rng)[]\nRangeTrees.intersect!(isects, rng, refrangetrees[:chr01])\n\n12-element Vector{UnitRange{Int32}}:\n 14355:14409\n 14404:14501\n 15005:15038\n 15796:15947\n 16607:16765\n 16858:17055\n 17233:17368\n 17369:17436\n 17606:17742\n 17915:18061\n 18268:18366\n 24738:24891\n\n\n\nMake sure isects is properly re-initialized\n\n\nRangeTrees.intersect!(isects, rng, refrangetrees[:chr01])\n\n12-element Vector{UnitRange{Int32}}:\n 14355:14409\n 14404:14501\n 15005:15038\n 15796:15947\n 16607:16765\n 16858:17055\n 17233:17368\n 17369:17436\n 17606:17742\n 17915:18061\n 18268:18366\n 24738:24891\n\n\n\n@benchmark intersect(rg, rt) setup=(rg = rng; rt = refrangetrees[:chr01])\n\n\nBenchmarkTools.Trial: 10000 samples with 243 evaluations.\n Range (min … max):  311.280 ns … 57.088 μs  ┊ GC (min … max):  0.00% … 99.02%\n Time  (median):     415.807 ns              ┊ GC (median):     0.00%\n Time  (mean ± σ):   431.023 ns ±  1.583 μs  ┊ GC (mean ± σ):  10.37% ±  2.80%\n  ▂█                                                            \n  ██▇▄▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▃▄▅▅▄▄▄▄▅▆▆▅▄▄▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂ ▃\n  311 ns          Histogram: frequency by time          503 ns <\n Memory estimate: 480 bytes, allocs estimate: 3.\n\n\n\n\n@benchmark RangeTrees.intersect!(res, rg, rt) setup=(res = isects; rg = rng; rt = refrangetrees[:chr01])\n\n\nBenchmarkTools.Trial: 10000 samples with 372 evaluations.\n Range (min … max):  245.452 ns … 426.809 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     250.770 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   252.932 ns ±  11.093 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n   ▃▆██▅▃▃▃▅▁                                                   ▂\n  ▇███████████▇▅█▄▄▄▁▃▃▃▁▁▁▁▁▁▁▇█▇▇▇▇█▇▇▇▄▅▃▃▅▄▄▁▄▁▄▁▁▁▁▁▁▁▁▁▅▆ █\n  245 ns        Histogram: log(frequency) by time        323 ns <\n Memory estimate: 0 bytes, allocs estimate: 0.\n\n\n\n\nWe see that intersect! performs a bit better than intersect on a RangeTree but it will complicate multithreading.\n\n\nfunction overlap(target::UnitRange{T}, reference::RangeTree{T}) where {T}\n  n = 0\n  coverage = 0\n  goalposts = target\n  rightpost = last(goalposts)\n  for ivl in intersect(target, reference)\n    n += 1\n    coverage += length(intersect(goalposts, ivl))\n    goalposts = (last(ivl) + one(T)):rightpost\n  end\n  return n, coverage\nend\nsampleresult == overlaps(rnasamp, refrangetrees)\n\ntrue\n\n\n\n@benchmark overlaps(rtbl, rngtr)  setup=(rtbl = rnasamp; rngtr=refrangetrees)\n\n\nBenchmarkTools.Trial: 886 samples with 1 evaluation.\n Range (min … max):  3.209 ms … 91.147 ms  ┊ GC (min … max):  0.00% … 95.03%\n Time  (median):     4.205 ms              ┊ GC (median):     0.00%\n Time  (mean ± σ):   5.630 ms ± 10.613 ms  ┊ GC (mean ± σ):  24.54% ± 12.21%\n  █ ▁                                                         \n  ███▅▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃▁▁▄▅ ▇\n  3.21 ms      Histogram: log(frequency) by time     85.2 ms <\n Memory estimate: 8.50 MiB, allocs estimate: 51989.\n\n\n\n\nfunction overlap!(result::Vector{UnitRange{T}}, target::UnitRange{T}, reference::RangeTree{T}) where {T}\n  coverage = 0\n  goalposts = target\n  rightpost = last(goalposts)\n  for ivl in RangeTrees.intersect!(empty!(result), target, reference)\n    coverage += length(intersect(goalposts, ivl))\n    goalposts = (last(ivl) + one(T)):rightpost\n  end\n  return length(result), coverage\nend\noverlap!(UnitRange{Int32}[], first(rnartbl).range, refrangetrees[:chr01])\n\n(12, 1431)\n\n\n\nfunction overlaps!(targets::AbstractVector{<:NamedTuple}, refs::Dict)\n  nover = similar(targets, (length(targets) ≤ typemax(Int32) ? Int32 : Int64))\n  firstrange = first(targets).range\n  coverage = similar(targets, typeof(first(firstrange)))\n  scratch = [typeof(firstrange)[] for _ in 1:Threads.nthreads()]\n  @inbounds Threads.@threads for i in eachindex(targets)\n    tup = targets[i]\n    nover[i], coverage[i] = overlap!(scratch[Threads.threadid()], tup.range, refs[tup.chromo])\n  end\n  return DataFrame((; nover, coverage))\nend\nsampleresult == overlaps!(rnasamp, refrangetrees)\n\ntrue\n\n\n\n@benchmark overlaps!(targets, refs) setup=(targets = rnasamp; refs = refrangetrees)\n\n\nBenchmarkTools.Trial: 1631 samples with 1 evaluation.\n Range (min … max):  2.658 ms …   5.185 ms  ┊ GC (min … max): 0.00% … 33.74%\n Time  (median):     2.979 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   3.056 ms ± 275.570 μs  ┊ GC (mean ± σ):  0.10% ±  1.47%\n       ▅██▄▂▁           ▁                                      \n  ▂▂▂▄████████▆▇▆▄▄▅▄▅▆▅███▇▇▇▆▆▆▆▆▅▅▄▄▃▂▃▂▂▁▂▃▂▁▁▂▂▁▁▁▁▁▁▁▁▂ ▄\n  2.66 ms         Histogram: frequency by time        3.96 ms <\n Memory estimate: 333.56 KiB, allocs estimate: 73.\n\n\n\n\n@time overlaps!(rnartbl, refrangetrees);\n\n  0.451329 seconds (108 allocations: 71.538 MiB, 0.37% gc time)"
  },
  {
    "objectID": "session2b-interval-overlap.html#conclusions",
    "href": "session2b-interval-overlap.html#conclusions",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Conclusions",
    "text": "Conclusions\n\nThe ability to work in the REPL (or VS Code or Jupyter notebooks) encourages iterative refinement of algorithms.\n“Trust but verify” - when making a change or introducing new methods it helps to have results from previous methods for comparison. In general, continuous integration (CI) testing is straightforward for Julia packages and is strongly encouraged.\nThere are many tools for benchmarking function execution or storage allocation, allowing a developer to concentrate on where the “real problem” is.\nIn certain cases, enhancements like multi-threading can be achieved with very little effort."
  },
  {
    "objectID": "session2b-interval-overlap.html#version-information",
    "href": "session2b-interval-overlap.html#version-information",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Version information",
    "text": "Version information\n\nversioninfo()\n\nJulia Version 1.8.0-rc1\nCommit 6368fdc656 (2022-05-27 18:33 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: 4 × Intel(R) Core(TM) i5-7500 CPU @ 3.40GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, skylake)\n  Threads: 4 on 4 virtual cores"
  },
  {
    "objectID": "session4-exercise.html",
    "href": "session4-exercise.html",
    "title": "Hands-on exercise",
    "section": "",
    "text": "Instructions: Participants will translate their R/python script to Julia with assistance from the workshop presenters and TAs. After the 60 minutes, one or two volunteers will share their script to the group.\n\nChecklist\n\nDo you have Julia installed? If not, go to the housekeeping notes\nDo you have your project folder and installed dependencies? If not, go to the getting started nodes\nDo you have your data in your project folder?\nHave you selected an editor to use (VSCode, Emacs, Jupyter notebooks,…)? Check out the available options in the Julia website\n\nYou are ready to start writing Julia code! You can start with a simple .jl file, or you could try with a jupyter notebook or a .qmd file."
  },
  {
    "objectID": "session6-conclusions.html",
    "href": "session6-conclusions.html",
    "title": "Session 6: Conclusions",
    "section": "",
    "text": "Julia provides many advantages to data science programmers especially those creating programs that need to be efficient and that will be shared with the scientific community\nJulia allows programmers to easily write good performant code and avoid the two language problem\n\nAmong the main Julia tools, we focused on five:\n\n\n\nArrow.jl: memory, layout, data frame, binary form. The binary form allows for cross-platform use (julia, R, python). Need to be careful going from Julia to R\nTables.jl: generic idea of data table; row oriented (vector of named tuples) or column oriented (named tuple of vectors)\nDataFrames.jl: cheatsheet similar to tidyverse; split-apply-combine\n\n\n\n\n\nMixedModels.jl: 100% julia package\n\n\n\n\n\nRCall.jl: 100% julia package\nPyCall.jl: 100% julia package\n\n\n\n\n\nWith Julia 1.7+, precompilation is done when the package is added\n\n\n\n\n\nPerformance tips\nProfiling\n\n\n\n\n\nMakie ecosystem\nPlots.jl\n\n\n\n\n\nquarto.org. These notes are rendered with quarto!\nJupyter\nPluto.jl"
  }
]