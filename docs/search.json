[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia Workshop for Data Science",
    "section": "",
    "text": "Schedule\n\n\n\nTime\nTopic\nPresenter\n\n\n\n\n11:00 - 11:30\nSession 1: Get Started with Julia\nClaudia Solis-Lemus\n\n\n11:30 - 12:30\nSession 2a: Data Tables and Arrow files\nDoug Bates\n\n\n12:30 - 1:00\nSession 2b: Interval Overlap\nDoug Bates\n\n\n1:00 - 2:00\nLunch break\n\n\n\n2:00 - 3:00\nSession 3: Model fitting\n\n\n\n3:00 - 4:00\nSession 4: Hands-on exercise\nSam Ozminkowski and Bella Wu\n\n\n4:00 - 4:15\nCoffee break\n\n\n\n4:15 - 5:00\nPresentation of selected participants’ scripts and Q&A\n\n\n\n5:00 - 5:30\nSession 5: Other important Data Science tools\nClaudia Solis-Lemus\n\n\n5:30 - 6:00\nSession 6: Conclusions and questions\nClaudia Solis-Lemus\n\n\n\n\n\nIn preparation for the workshop\nParticipants are required to follow the next steps before the day of the workshop:\n\nGit clone the workshop repository: git clone https://github.com/crsl4/julia-workshop.git\nInstall Julia. The recommended option is to use JuliaUp:\n\n\nWindows: winget install julia -s msstore\nMac and Linux: curl -fsSL https://install.julialang.org | sh\nHomebrew users: brew install juliaup\n\nAfter JuliaUp is installed, you can install different Julia versions with:\njuliaup add release  ## installs release version\njuliaup add rc     ## installs rc version\njuliaup st           ## status of julia versions installed\njuliaup default rc ## making beta version the default\n\nChoose a dataset along with a script to analyze it written in another language (R or python) as we will spend part of the workshop translating participants’ scripts to Julia."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This tutorial will provide an introduction to key Data Science tools in Julia such as data management with Arrow.jl and Tables.jl and (Generalized) linear mixed models with GLMM.jl and MixedModels.jl. Unlike widely used R packages, all packages that we will describe are written 100% in Julia thus illustrating the language’s potential to overcome the two-language problem.\nThis tutorial will appeal to anyone interested in learning more about Julia and some of the existing Julia packages that are already available for Statistics and Data Science. In addition to lectures, participants will engage in hands-on exercises. For example, participants will bring a dataset of their choice along with an existing script written in another language (R or python) that performs certain data analyses. During the tutorial, participants will translate their work to Julia in-order to compare running times and ease of programming."
  },
  {
    "objectID": "session1-get-started.html",
    "href": "session1-get-started.html",
    "title": "Session 1: Getting started with Julia",
    "section": "",
    "text": "“We want a language that is\n\nopen source\nwith the speed of C\nobvious, familiar mathematical notation like Matlab\nas usable for general programming as Python\nas easy for statistics as R\nas natural for string processing as Perl\nas powerful for linear algebra as Matlab\nas good at gluing programs together as the shell\ndirt simple to learn, yet keeps the most serious hackers happy”\n\n\n\n\n\nComparison with other languages: Julia touts its speed edge over Python and R\nUsed for large-scale projects like CliMA 0.1: a first milestone in the next generation of climate models\n\nClimateMachine.jl\n\nJulia adoption accelerated at a rapid pace in 2020:\n\n\n\n\n\n\n\n\nUse the REPL as a sophisticated calculator\nRealize that you are repeating many operations, so you decide to write some functions\nTo organize all your functions, you begin scripting\nYou want to share your code with others and thus, you want to write a package\nYour package is actually used by others and thus, it should be optimized and have good performance\n\nJulia offers many advantages to data science programmers such as avoid the two-language problem and existing tools that allows programmers to write efficient code without having to write everything from scratch!"
  },
  {
    "objectID": "session1-get-started.html#how-do-i-write-code",
    "href": "session1-get-started.html#how-do-i-write-code",
    "title": "Session 1: Getting started with Julia",
    "section": "How do I write code?",
    "text": "How do I write code?"
  },
  {
    "objectID": "session1-get-started.html#installing-dependencies-in-a-project-environment",
    "href": "session1-get-started.html#installing-dependencies-in-a-project-environment",
    "title": "Session 1: Getting started with Julia",
    "section": "Installing dependencies in a project environment",
    "text": "Installing dependencies in a project environment\nThere are two alternatives:\n\nUsing an existing project with dependencies already in Project.toml (this will be the case when you are collaborating with someone that already set up the project dependencies)\nSet up the dependencies for your project on your own (this will be the case if your project is new)\n\nFor this workshop, participants will use the workshop GitHub repository as the existing project that already has all the dependencies. However, we also show the steps below to create a new project from scratch.\n\n1. Working on an existing project environment\nGit clone the repository:\ngit clone https://github.com/crsl4/julia-workshop.git\nOpen julia and activate the package with:\njulia --project\nAlternatively, you can open julia normally, and type ] activate .\nThen, instantiate the package (install dependencies) with:\n] instantiate\n] update\nNow, you should be able to follow along the workshop commands. Trouble-shooting might be needed when we reach the interoperability with Python and R as certain libraries or packages might need to be installed too.\n\n\n2. Creating a new project environment\nCreate a folder in the terminal:\nmkdir myProject\ncd myProject\nOpen Julia inside your folder, and activate your environment with:\n(@v1.8) pkg> activate .\nInstall the packages that we need. For example, the packages needed for today’s workshop are:\njulia> ENV[\"PYTHON\"] = \"\"\n(myproject) pkg> add PyCall\n(myproject) pkg> add IJulia\n(myproject) pkg> build IJulia\n(myproject) pkg> add MixedModels\n(myproject) pkg> add RCall\n(myproject) pkg> add Arrow\n(myproject) pkg> add DataFrames\n(myproject) pkg> add Tables\n(myproject) pkg> add RangeTrees\nTwo files are noteworthy:\n\nProject.toml: Defines project\nManifest.toml: Contains exact list of project dependencies\n\nshell> head Project.toml\n[deps]\nArrow = \"69666777-d1a9-59fb-9406-91d4454c9d45\"\nDataFrames = \"a93c6f00-e57d-5684-b7b6-d8193f3e46c0\"\nIJulia = \"7073ff75-c697-5162-941a-fcdaad2a7d2a\"\nMixedModels = \"ff71e718-51f3-5ec2-a782-8ffcbfa3c316\"\nPyCall = \"438e738f-606a-5dbb-bf0a-cddfbfd45ab0\"\nRCall = \"6f49c342-dc21-5d91-9882-a32aef131414\"\nTables = \"bd369af6-aec1-5ad0-b16a-f7cc5008161c\"\n\n\nshell> head Manifest.toml\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = \"1.8.0-beta3\"\nmanifest_format = \"2.0\"\nproject_hash = \"01baf737705b090869a607b779c699f83bbeb154\"\n\n[[deps.ArgTools]]\nuuid = \"0dad84c5-d112-42e6-8d28-ef12dabb789f\"\nversion = \"1.1.1\"\nLook at your Project.toml and Manifest.toml files after installation. They have all the necessary information about your session.\nThe packages have a uuid string which is the universally unique identifier.\nMore on the Project.toml and Manifest.toml files here."
  },
  {
    "objectID": "session1-get-started.html#easy-share-with-collaborators",
    "href": "session1-get-started.html#easy-share-with-collaborators",
    "title": "Session 1: Getting started with Julia",
    "section": "Easy share with collaborators",
    "text": "Easy share with collaborators\nShare your project to colleagues. Send your entire project folder to your colleague, and all they need to do is:\njulia> cd(\"path/to/project\")\npkg> activate .\npkg> instantiate\nAll required packages and dependencies will be installed. Scripts that run in your computer will also run in their computer."
  },
  {
    "objectID": "session2a-tables-and-arrow.html",
    "href": "session2a-tables-and-arrow.html",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "",
    "text": "Code\nusing Arrow             # Arrow storage and file format\nusing CategoricalArrays # similar to the factor type in R\nusing CSV               # read/write CSV and similar formats\nusing Downloads         # file downloads\nusing DataFrames        # versatile tabular data format\nusing GZip              # utilities for compressed files\nusing RCall             # run R within Julia\nusing Tar               # tar archive utilities\n\n\nDownloads, Gzip and Tar are included just to demonstrate downloading and extracting tar files within Julia.\nYou may find it easier to simply click on the download link and extract the files by hand.\nDownloading and extracting within Julia, as shown here, has a greater chance of working across various operating systems and environments in a workshop like this.\nRCall is included to show the use of other systems running within Julia.\nYou can instead use your favorite environment, such as jupyterlab or RStudio, to run Python or R\nNote that the quarto notebooks for these notes are easily converted, e.g. quarto convert notebookname.qmd, to Jupyter notebooks.\n\n\n\n\n\n\n\nNote\n\n\n\nBoxes like this contain comments on Julia syntax and semantics in code examples."
  },
  {
    "objectID": "session2a-tables-and-arrow.html#objectives",
    "href": "session2a-tables-and-arrow.html#objectives",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Objectives",
    "text": "Objectives\n\nUse an example of computing interval overlaps to introduce Julia facilities for working with tabular data.\nIntroduce the Arrow format for tabular data and demonstrate its use in Julia, Python/Pandas and R.\nShow a naive approach to computing overlaps.\nModify the approach to use IntervalTrees.jl and multi-threading.\nRoll our own interval tree representation and use that.\n\nThis notebook covers the first two objectives."
  },
  {
    "objectID": "session2a-tables-and-arrow.html#task-and-sample-data",
    "href": "session2a-tables-and-arrow.html#task-and-sample-data",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Task and sample data",
    "text": "Task and sample data\n\nLi Heng provides benchmark code and sample data for comparing programming languages on Bioinformatics tasks in his biofast repository.\nOne of these tasks, an interval query, takes two .bed files to compare.\nOne file, ex-anno.bed, contains a reference set of intervals; the other, ex-rna.bed, contains target intervals.\nFor each target interval, determine which reference intervals overlap with it.\nIn the benchmark both the number of reference intervals that overlap with a target and the proportion of the target covered by the overlap are computed.\nNote that the calculation of the proportion of overlap must allow for overlapping intervals in the reference set, as shown in this figure"
  },
  {
    "objectID": "session2a-tables-and-arrow.html#downloading-the-sample-data",
    "href": "session2a-tables-and-arrow.html#downloading-the-sample-data",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Downloading the sample data",
    "text": "Downloading the sample data\n\nThe data sets for the benchmark are available in the compressed archive biofast-data-v1.tar.gz at biofast-data-v1.\nThe following code chunks download the tarball, if necessary, and extract the two bedfiles to a directory biofast-data-v1, if necessary. (Alternatively, you can just click on the link to the tarball in the github tag page and extract the files by hand.)\n\n\ndatadir = \"biofast-data-v1\"\ntarball = \"$datadir.tar.gz\"\nif !isfile(tarball)\n  dataurl = joinpath(\n    \"https://github.com/lh3/biofast/releases/download\",\n    datadir,\n    tarball,\n  )\n  Downloads.download(dataurl, tarball)\nend\nrun(`ls -lh $tarball`);\n\n-rw-rw-r-- 1 bates bates 541M Jun 16 13:34 biofast-data-v1.tar.gz\n\n\n\n\n\n\n\n\nNote\n\n\n\nAn expression like \"$datadir.tar.gz\" interpolates the value of datadir into the string, producing the name shown in the output.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nRedundant commas are allowed at the end of the list of arguments before the ) in a function call.\n\n\n\n\nThe .tar.gz file is about 0.5 GB. but most of that is the data for the FASTQ parsing test.\nExtract the two .bed files to be used in this example, if not already present.\n\n\nisdir(datadir) || mkdir(datadir)\nbedfnms = joinpath.(datadir, [\"ex-anno.bed\", \"ex-rna.bed\"])\ntoextract = filter(!isfile, bedfnms)  # don't overwrite existing files\nif !isempty(toextract)\n  tmpdir = gzopen(tarball, \"r\") do io\n    Tar.extract(h -> in(h.path, toextract), io)\n  end\n  for pathnm in toextract\n    mv(joinpath(tmpdir, pathnm), pathnm; force=true)\n  end\nend\nrun(`ls -lh $datadir`);\n\ntotal 273M\n-rw-rw-r-- 1 bates bates 3.9M Jun 16 13:34 ex-anno.arrow\n-rw-r--r-- 1 bates bates  28M Jun 16 13:34 ex-anno.bed\n-rw-rw-r-- 1 bates bates  39M Jun 16 13:34 ex-rna.arrow\n-rw-r--r-- 1 bates bates 203M Jun 16 13:34 ex-rna.bed\n\n\n\n\n\n\n\n\nNote\n\n\n\nBecause of the way Quarto documents are rendered, this listing may show .arrow files that are generated later in this document.\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe call joinpath.(datadir, [\"ex-anno.bed\", \"ex-rna.bed\"]) is an example of dot broadcasting\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe expression h -> in(h.path, toextract) defines an anonymous function, in the “stabby lambda” syntax, to be used as a predicate in Tar.extract.\n\nmethods(Tar.extract)\n\n# 4 methods for generic function extract: extract(predicate::Function, tarball::Union{Base.AbstractCmd, AbstractString, IO}) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:218  extract(predicate::Function, tarball::Union{Base.AbstractCmd, AbstractString, IO}, dir::Union{Nothing, AbstractString}; skeleton, copy_symlinks, set_permissions) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:218  extract(tarball::Union{Base.AbstractCmd, AbstractString, IO}) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:248  extract(tarball::Union{Base.AbstractCmd, AbstractString, IO}, dir::Union{Nothing, AbstractString}; skeleton, copy_symlinks, set_permissions) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:248 \n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe ‘do/end’ block is yet another way of writing an anonymous function passed as a processing argument to gzopen.\n\nmethods(gzopen)\n\n# 4 methods for generic function gzopen: gzopen(fname::AbstractString) in GZip at /home/bates/.julia/packages/GZip/JNmGn/src/GZip.jl:264  gzopen(fname::AbstractString, gzmode::AbstractString) in GZip at /home/bates/.julia/packages/GZip/JNmGn/src/GZip.jl:263  gzopen(fname::AbstractString, gzmode::AbstractString, gz_buf_size::Integer) in GZip at /home/bates/.julia/packages/GZip/JNmGn/src/GZip.jl:236  gzopen(f::Function, args...) in GZip at /home/bates/.julia/packages/GZip/JNmGn/src/GZip.jl:267 \n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nBecause Tar.extract is conservative about overwriting files and requires that the directory into which the files are extracted be empty, we extract to a freshly-created temporary directory then move the files to the desired location.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nIt is common for packages providing utilities to avoid name conflicts by not exporting any names from their namespace (or Module).\nThe fully qualified name, Tar.extract, can always be used - similar to Python naming conventions.\nIf a package exports a name, say foo, then after the using FooPackage directive, the unqualified name foo can be used.\nThe varinfo function provides a listing of the names exported by a Package (formally the package’s Module).\nCompare the result of varinfo(Tar) with that of varinfo(DataFrames)."
  },
  {
    "objectID": "session2a-tables-and-arrow.html#initial-processing",
    "href": "session2a-tables-and-arrow.html#initial-processing",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Initial processing",
    "text": "Initial processing\n\nThe .bed files, in this case, are simple tab-separated-value files.\nEach of the language implementations in the biofast benchmark contains code to parse lines of the .bed files producing a String and two Int32 values.\nFurthermore the results of these benchmarks are written out as very large text files. I don’t plan to read a several-million-line text file to check if a program is working properly.\nWhy go through this parsing of text files to create a numeric representation in each language?\nWriting code to parse a CSV or TSV file is tedious and error prone.\nBut skilled people have put a lot of work into creating packages to do just that.\nMore importantly they have tested, debugged, and documented their packages.\nWithin the CSV package, the CSV.read function reads and parses a file and converts it to a type specified by the second argument.\nAs is common for such functions, there are many, many optional named arguments\nWe read ex-anno.bed and create a DataFrame as\n\n\nannodf = CSV.read(\n  joinpath(datadir, \"ex-anno.bed\"),\n  DataFrame;\n  delim='\\t',\n  types=[String, Int32, Int32],\n  header=[\"chromo\", \"start\", \"stop\"],\n)\n\n\n1,193,657 rows × 3 columnschromostartstopStringInt32Int321chr111868122272chr112612127213chr113220144094chr112009120575chr112178122276chr112612126977chr112974130528chr113220133749chr1134521367010chr1295332957011chr1247372489112chr1182671836613chr1179141806114chr1176051774215chr1172321736816chr1168571705517chr1166061676518chr1157951594719chr1150041503820chr1144031450121chr1173681743622chr1295533003923chr1305633066724chr1309753109725chr1302663066726chr1309753110927chr1303653050328chr1357203608129chr1352763548130chr13455335174⋮⋮⋮⋮\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nPositional arguments must come before named arguments.\nOptionally, the comma after the last positional argument can be replace by a semicolon, as shown above.\n\n\n\n\nIt turns out that both of the .bed files contain many duplicate rows - probably not intentionally. Eliminate the duplicates with unique!.\n\n\n\n\n\n\n\nNote\n\n\n\nA function’s name ending in ! is a hint that it is a mutating function, which can modify one or more of its arguments.\n\n\n\nDo make one change of replacing the tags \"chr1\" up to \"chr9\" by \"chr01\" to \"chr09\" so later sorting by these strings will also give sorted chromosome numbers.\nWe use a replace! method takes the object to modify and one or more pairs of values of the form from => to and generate the replacements as\n\n\nreplacements =  [\"chr$i\" => \"chr0$i\" for i in 1:9]\n\n9-element Vector{Pair{String, String}}:\n \"chr1\" => \"chr01\"\n \"chr2\" => \"chr02\"\n \"chr3\" => \"chr03\"\n \"chr4\" => \"chr04\"\n \"chr5\" => \"chr05\"\n \"chr6\" => \"chr06\"\n \"chr7\" => \"chr07\"\n \"chr8\" => \"chr08\"\n \"chr9\" => \"chr09\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe expression on the right of the = is called a “comprehension”. I think of it as an inside-out loop.\n\n\n\nshow(unique(replace!(annodf.chromo, replacements...)))\n\n[\"chr01\", \"chr02\", \"chr03\", \"chr04\", \"chr05\", \"chr06\", \"chr07\", \"chrX\", \"chr08\", \"chr09\", \"chr11\", \"chr10\", \"chr12\", \"chr13\", \"chr14\", \"chr15\", \"chr16\", \"chr17\", \"chr18\", \"chr20\", \"chr19\", \"chrY\", \"chr22\", \"chr21\"]\n\n\n\nunique!(annodf)\nannodf.chromo = categorical(annodf.chromo)\nannodf\n\n\n573,806 rows × 3 columnschromostartstopCat…Int32Int321chr0111868122272chr0112612127213chr0113220144094chr0112009120575chr0112178122276chr0112612126977chr0112974130528chr0113220133749chr01134521367010chr01295332957011chr01247372489112chr01182671836613chr01179141806114chr01176051774215chr01172321736816chr01168571705517chr01166061676518chr01157951594719chr01150041503820chr01144031450121chr01173681743622chr01295533003923chr01305633066724chr01309753109725chr01302663066726chr01309753110927chr01303653050328chr01357203608129chr01352763548130chr013455335174⋮⋮⋮⋮\n\n\n\n\n\n\n\n\nNote\n\n\n\nRepresenting the chromo column as a CategoricalArray converts the individual values to indices into a vector of Strings, which saves on space."
  },
  {
    "objectID": "session2a-tables-and-arrow.html#arrow-file-format",
    "href": "session2a-tables-and-arrow.html#arrow-file-format",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Arrow file format",
    "text": "Arrow file format\n\nThe Arrow project defines a memory and file format for storing and manipulating column-oriented, static, tables (i.e. like data frames in R, Python/Pandas, and Julia)\nEither ‘lz4’ or ‘zstd’ compression can be used when creating an Arrow file.\nMetadata on the names and types of columns is automatically stored. Additional column or table metadata can be specified.\n\n\nArrow.write(\n  \"./biofast-data-v1/ex-anno.arrow\",\n  annodf;\n  compress=:lz4,\n  metadata=[\n    \"url\" =>\n    \"https://github.com/lh3/biofast/releases/tag/biofast-data-v1\",\n  ],\n)\n\n\"./biofast-data-v1/ex-anno.arrow\"\n\n\n\nbed2arrow encapsulates reading the .bed file, replacing the strings in the chromo column, reducing the data frame to unique, sorted rows, and writing the Arrow file.\nNamed arguments with defaults are used to configure the “usual” call but allow for variations.\nThe Boolean overwrite named argument, which defaults to false, controls overwriting of existing files.\n\n\nmetadata = [\"url\" => \"https://github.com/lh3/biofast/releases/tag/biofast-data-v1\",]\nfunction bed2arrow(\n  fnroot::AbstractString;\n  datadir=datadir,\n  delim='\\t',\n  header=[:chromo, :start, :stop],\n  types=[String, Int32, Int32],\n  compress=:lz4,\n  metadata=metadata,\n  replacements=replacements,\n  overwrite::Bool=false,\n)\n  bednm = joinpath(datadir, \"$fnroot.bed\")\n  arrownm = joinpath(datadir, \"$fnroot.arrow\")\n  if overwrite || !isfile(arrownm)\n    df = unique!(CSV.read(bednm, DataFrame; header, delim, types))\n    replace!(df.chromo, replacements...)\n    df.chromo = categorical(df.chromo)\n    Arrow.write(arrownm, df; compress, metadata)\n  end\n  return arrownm\nend\nrnaarrownm = bed2arrow(\"ex-rna\")\n\n\"biofast-data-v1/ex-rna.arrow\"\n\n\n\nrun(`ls -lh $datadir`);\n\ntotal 273M\n-rw-rw-r-- 1 bates bates 3.9M Jun 16 13:37 ex-anno.arrow\n-rw-r--r-- 1 bates bates  28M Jun 16 13:34 ex-anno.bed\n-rw-rw-r-- 1 bates bates  39M Jun 16 13:34 ex-rna.arrow\n-rw-r--r-- 1 bates bates 203M Jun 16 13:34 ex-rna.bed\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the calls to CSV.read and Arrow.write, the semicolon after the positional arguments followed by argument names only indicates that the value passed for the named argument is the object of the same name in the current namespace. That is, Arrow.write(arrownm, df; compress, metadata) is equivalent to Arrow.write(arrownm, df; compress=compress, metadata=metadata)."
  },
  {
    "objectID": "session2a-tables-and-arrow.html#reading-arrow-files-in-julia",
    "href": "session2a-tables-and-arrow.html#reading-arrow-files-in-julia",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Reading Arrow files in Julia",
    "text": "Reading Arrow files in Julia\n\nannotbl = Arrow.Table(\"./biofast-data-v1/ex-anno.arrow\")\n\nArrow.Table with 573806 rows, 3 columns, and schema:\n :chromo  String\n :start   Int32\n :stop    Int32\n\nwith metadata given by a Base.ImmutableDict{String, String} with 1 entry:\n  \"url\" => \"https://github.com/lh3/biofast/releases/tag/biofast-data-v1\"\n\n\n\nAlthough the schema describes the chromo column as Strings the values are dictionary encoded such that each value is represented by one byte.\n\n\ntypeof(annotbl.chromo)\n\nArrow.DictEncoded{String, Int8, Arrow.List{String, Int32, Vector{UInt8}}}\n\n\n\n@time rnatbl = Arrow.Table(rnaarrownm)\n\n  0.055941 seconds (325 allocations: 77.842 MiB)\n\n\nArrow.Table with 4685080 rows, 3 columns, and schema:\n :chromo  String\n :start   Int32\n :stop    Int32\n\nwith metadata given by a Base.ImmutableDict{String, String} with 1 entry:\n  \"url\" => \"https://github.com/lh3/biofast/releases/tag/biofast-data-v1\"\n\n\n\nWe can use operations like split-apply-combine on these tables to summarize properties\n\n\nannogdf = groupby(DataFrame(annotbl), :chromo)\nrnagdf = groupby(DataFrame(rnatbl), :chromo)\ninnerjoin(\n  combine(rnagdf, nrow => :nrna),\n  combine(annogdf, nrow => :nanno);\n  on=:chromo,\n)  \n\n\n24 rows × 3 columnschromonrnanannoStringInt64Int641chr01453114527892chr02298278425633chr03251858347694chr04132781225005chr05225898260856chr06307747249357chr07217038276138chr08141205216039chr091651812018910chr101622562006111chr112865843402112chr122920023352413chr1376779946414chr141714021999515chr151717362218716chr161925952827617chr172883483588818chr18604291017919chr193447753545120chr201099791238721chr2151720651822chr221329561272423chrX1503301761824chrY892467\n\n\n\nIn the next section we will use data from chr21 for comparative timings, because there are small, but nontrivial, number of intervals in both the reference and target groups."
  },
  {
    "objectID": "session2a-tables-and-arrow.html#reading-arrow-files-in-r",
    "href": "session2a-tables-and-arrow.html#reading-arrow-files-in-r",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Reading Arrow files in R",
    "text": "Reading Arrow files in R\n\nIn R (and in Python) the Arrow file format is confounded with an earlier file format called Feather and referred to as Feather V2.\nIn R the arrow::read_feather function returns a tibble. In an R session it looks like\n\n> library(tibble)\n> arrow::read_feather(\"biofast-data-v1/ex-rna.arrow\")\n# A tibble: 4,685,080 × 3\n   chromo     start      stop\n   <fct>      <int>     <int>\n 1 chr02  216499331 216501458\n 2 chr07  101239611 101245071\n 3 chr19   49487626  49491841\n 4 chr10   80155590  80169336\n 5 chr17   76270411  76271290\n 6 chr06   31268756  31272069\n 7 chr05  170083214 170083368\n 8 chr19   51989731  51989996\n 9 chr18   55225980  55226732\n10 chr16   84565611  84566066\n# … with 4,685,070 more rows\n\nThe RCall package in Julia allows for running an R process within a Julia session.\nOne way of executing R code with RCall is to prepend R to a string. This causes the string to be evaluated in R.\n$-interpolation in the string causes a Julia object to be copied into the R environment and its name in R interpolated.\n\n\nR\"\"\"\nlibrary(tibble)\nglimpse(rnatbl <- arrow::read_feather($rnaarrownm))\n\"\"\";\n\nRows: 4,685,080\nColumns: 3\n$ chromo <fct> chr02, chr07, chr19, chr10, chr17, chr06, chr05, chr19, chr18, …\n$ start  <int> 216499331, 101239611, 49487626, 80155590, 76270411, 31268756, 1…\n$ stop   <int> 216501458, 101245071, 49491841, 80169336, 76271290, 31272069, 1…"
  },
  {
    "objectID": "session2a-tables-and-arrow.html#reading-arrow-files-in-python",
    "href": "session2a-tables-and-arrow.html#reading-arrow-files-in-python",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Reading Arrow files in Python",
    "text": "Reading Arrow files in Python\n\nThe pyarrow package includes pyarrow.feather. Its use in a Python session looks like\n\n>>> import pyarrow.feather as fea\n>>> fea.read_table('./biofast-data-v1/ex-rna.arrow')\npyarrow.Table\nchromo: dictionary<values=string, indices=int8, ordered=0> not null\nstart: int32 not null\nstop: int32 not null\n----\nchromo: [  -- dictionary:\n[\"chr01\",\"chr02\",\"chr03\",\"chr04\",\"chr05\",...,\"chr20\",\"chr21\",\"chr22\",\"chrX\",\"chrY\"]  -- indices:\n[1,6,18,9,16,...,16,15,10,22,0]]\nstart: [[216499331,101239611,49487626,80155590,76270411,...,7014179,75627747,59636724,153785767,182839364]]\nstop: [[216501458,101245071,49491841,80169336,76271290,...,7014515,75631483,59666963,153787586,182887745]]\n>>> fea.read_feather('./biofast-data-v1/ex-rna.arrow')\n        chromo      start       stop\n0        chr02  216499331  216501458\n1        chr07  101239611  101245071\n2        chr19   49487626   49491841\n3        chr10   80155590   80169336\n4        chr17   76270411   76271290\n...        ...        ...        ...\n4685075  chr17    7014179    7014515\n4685076  chr16   75627747   75631483\n4685077  chr11   59636724   59666963\n4685078   chrX  153785767  153787586\n4685079  chr01  182839364  182887745\n\n[4685080 rows x 3 columns]\n\nread_table returns a Table object, read_feather returns a Pandas dataframe.\nThe PyCall package for Julia starts a Python process and allows communication with it, including data transfer.\nI use this instead of the Python REPL when working with both Julia and Python.\nConfiguring Python, Conda, pyarrow, pandas, and PyCall across platforms is sufficiently complicated to almost surely cause failures for some workshop participants. Instead of evaluating this code chunk we quote the results.\n\njulia> using PyCall\n\njulia> fea = pyimport(\"pyarrow.feather\");\n\njulia> fea.read_table(rnaarrownm)\nPyObject pyarrow.Table\nchromo: dictionary<values=string, indices=int8, ordered=0> not null\nstart: int32 not null\nstop: int32 not null\n----\nchromo: [  -- dictionary:\n[\"chr01\",\"chr02\",\"chr03\",\"chr04\",\"chr05\",...,\"chr20\",\"chr21\",\"chr22\",\"chrX\",\"chrY\"]  -- indices:\n[1,6,18,9,16,...,16,15,10,22,0]]\nstart: [[216499331,101239611,49487626,80155590,76270411,...,7014179,75627747,59636724,153785767,182839364]]\nstop: [[216501458,101245071,49491841,80169336,76271290,...,7014515,75631483,59666963,153787586,182887745]]"
  },
  {
    "objectID": "session2a-tables-and-arrow.html#conclusions",
    "href": "session2a-tables-and-arrow.html#conclusions",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Conclusions",
    "text": "Conclusions\n\nJulia provides an impressive array of tools for Bioinformatics and similar tasks\nWe have shown the use of Arrow.jl, CategoricalArrays.jl CSV.jl, and DataFrames for data input, storage and manipulation.\nAlthough not shown here DataFrameMacros.jl (or DataFramesMeta.jl) and Chain.jl are worth considering for more sophisticated work with DataFrames.\nA general framework for working with tabular data is provided in Tables.jl (not shown here).\nWe have shown the use of PyCall.jl and RCall.jl for running and communicating with other language systems within Julia.\nWe have shown the use of utility packages Downloads.jl, GZip.jl and Tar.jl for scripting, say within Quarto documents like these.\nTake a moment to look at the repositories for some of these Julia packages. Most (all?) of them are 100% Julia code."
  },
  {
    "objectID": "session2a-tables-and-arrow.html#version-information",
    "href": "session2a-tables-and-arrow.html#version-information",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Version information",
    "text": "Version information\n\nversioninfo()\n\nJulia Version 1.8.0-rc1\nCommit 6368fdc656 (2022-05-27 18:33 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: 8 × 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, tigerlake)\n  Threads: 4 on 8 virtual cores"
  },
  {
    "objectID": "session2b-interval-overlap.html",
    "href": "session2b-interval-overlap.html",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "",
    "text": "Code\nusing Arrow          # Arrow storage and file format\nusing BenchmarkTools # tools for benchmarking code\nusing DataFrames     # versatile tabular data format\nusing IntervalTrees  # interval trees from BioJulia\nusing Random         # random number generation tools\nusing RangeTrees     # a bespoke implementation of interval trees\nusing Tables         # row- or column-oriented tabular data\n\nimport Base.intersect  # will create new methods for these generics\nimport Base.intersect!\n\ndatadir = \"biofast-data-v1\";"
  },
  {
    "objectID": "session2b-interval-overlap.html#strategy-for-computing-overlaps",
    "href": "session2b-interval-overlap.html#strategy-for-computing-overlaps",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Strategy for computing overlaps",
    "text": "Strategy for computing overlaps\n\nSplit the data in the Arrow data tables by chromosome tag and convert the start-stop pairs to a Vector{UnitRange}. For the reference intervals, sort the vectors by increasing first value.\nFor the reference intervals create two other dictionaries whose values are RangeTrees and IntervalTrees, respectively.\nBenchmark the intersection with a target UnitRange from each of the representations of the reference ranges. Do this in two ways: intersect, which allocates the storage for the result, and intersect!, which modifies one of its arguments.\nCompute the coverage from the vector of intersections.\nApply the methods to the complete set of targets.\n\n\nCreating dictionaries of Vector{UnitRange}\n\nA UnitRange, like 2:10, includes the end points (accessed as first and last).\n\n\ntypeof(2:10)\n\nUnitRange{Int64}\n\n\n\nlength(2:10)\n\n9\n\n\n\nThe positions in the start and stop columns in a .bed are not both included in the interval represented. The positions correspond to the interval start:(stop - 1) as 0-based positions or (start + 1):stop in 1-based positions.\nIt doesn’t matter which one we use as long as we are consistent.\nWe will start counting from 1, just like world’s greatest expert on counting does.\nWe wrap this conversion in a utility function to help ensure consistency.\n\n\nasrange(start, stop) = (start + one(start)):stop\n\nasrange (generic function with 1 method)\n\n\n\n\n\n\n\n\nNote\n\n\n\none(x) is used instead of the literal 1 in asrange to preserve the integer type (see also ?oneunit, which is slighly more general).\n\nst = Int32(2314)\ntypeof(st + 1)       # type gets promoted to Int64\n\nInt64\n\n\n\ntypeof(st + one(st)) # type not promoted\n\nInt32\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis method definition uses the compact “one-liner” form.\n\n\n\nfunction datatable(fnroot::AbstractString)\n  return DataFrame(Arrow.Table(joinpath(datadir, \"$fnroot.arrow\")))\nend\nfunction chromodict(df::DataFrame; sorted::Bool=false)\n  T = eltype(df.start)\n  vtype = Vector{UnitRange{T}}\n  dict = Dict{Symbol, vtype}()\n  for r in rowtable(sorted ? sort(df) : df)\n    (; chromo, start, stop) = r\n    push!(get!(dict, Symbol(chromo), vtype()), asrange(start, stop))\n  end\n  return dict\nend\nannorangevecs = chromodict(datatable(\"ex-anno\"); sorted=true)\n\nDict{Symbol, Vector{UnitRange{Int32}}} with 24 entries:\n  :chr21 => [5011799:5011874, 5012548:5012687, 5014386:5014471, 5016935:5017145…\n  :chr15 => [19878555:19878668, 19878831:19879004, 19881201:19881307, 19882277:…\n  :chr10 => [14061:14299, 14138:14299, 14497:14604, 16502:16544, 44712:44901, 4…\n  :chr17 => [64099:65736, 65830:65887, 71366:71556, 75814:75878, 76723:76866, 8…\n  :chr07 => [12704:12822, 19018:19172, 19619:19895, 20834:21029, 24314:24365, 2…\n  :chr14 => [16057472:16057622, 18333726:18333900, 18333826:18333896, 18337973:…\n  :chr08 => [64091:64175, 64269:64320, 72601:72673, 72617:72701, 78905:79244, 7…\n  :chr12 => [12310:12358, 12740:12824, 13102:13201, 13370:13501, 14522:14944, 1…\n  :chr18 => [11103:11595, 11191:11595, 13152:13354, 14195:14653, 14490:14653, 1…\n  :chrX  => [253743:253846, 254937:255091, 276322:276394, 276324:276394, 276353…\n  :chr13 => [18174010:18174103, 18174442:18174512, 18176018:18176170, 18177555:…\n  :chr11 => [75780:76143, 86649:87586, 112967:113111, 113116:113174, 121258:121…\n  :chr22 => [10736171:10736283, 10939388:10939423, 10940597:10940707, 10941691:…\n  :chr03 => [23757:23812, 23968:24501, 53348:53692, 54293:54346, 195758:195914,…\n  :chr19 => [60951:61894, 62113:66524, 63821:64213, 65051:65226, 65822:66047, 6…\n  :chr05 => [58198:58915, 92151:92276, 113251:113448, 139483:140716, 140258:140…\n  :chr06 => [95124:95454, 105919:106856, 131910:132117, 140211:140379, 142272:1…\n  :chr20 => [87250:87359, 87710:87767, 96005:96533, 96005:97094, 142369:142686,…\n  :chrY  => [2784749:2784853, 2786855:2787699, 2789827:2790328, 2827982:2828218…\n  :chr04 => [49096:49956, 49554:50124, 53285:53491, 53286:53491, 53295:53491, 5…\n  :chr02 => [38814:41627, 41220:41627, 41221:41627, 42809:42952, 45440:46385, 4…\n  :chr01 => [11869:12227, 12010:12057, 12179:12227, 12613:12697, 12613:12721, 1…\n  :chr09 => [12134:12190, 12291:12340, 12726:12834, 13088:13157, 13338:13487, 1…\n  :chr16 => [11555:11908, 11861:11908, 12294:12378, 12294:12402, 12663:12733, 1…\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe call get!(dict, Symbol(chromo), vtype()) in chromodict returns dict[Symbol(chromo)] or the default value, which is an empty Vector{UnitRange{T}}. For the case of the default, it also installs that key/value pair in dict.\n\n\n\nDo the same for the \"ex-rna\" intervals but don’t sort the vectors for each chromosome.\n\n\nrnarangevecs = chromodict(datatable(\"ex-rna\"))\n\nDict{Symbol, Vector{UnitRange{Int32}}} with 24 entries:\n  :chr21 => [8212585:8212728, 8207701:8252389, 8256795:8256941, 46189146:461895…\n  :chr15 => [55181315:55196932, 82536758:82540239, 82372221:82372895, 44711528:…\n  :chr10 => [80155591:80169336, 50305605:50306118, 96750280:96750926, 97426203:…\n  :chr17 => [76270412:76271290, 16031524:16031722, 1857276:1857405, 29551138:29…\n  :chr07 => [101239612:101245071, 5527161:5529285, 73569680:73572887, 5527151:5…\n  :chr14 => [105487209:105488788, 98972821:98973068, 105854220:105855113, 49583…\n  :chr12 => [56712431:56713192, 56712433:56724523, 22046215:22065551, 106973811…\n  :chr08 => [98041721:98045534, 144789769:144792143, 78732767:78733310, 9804172…\n  :chr18 => [55225981:55226732, 59903931:59904296, 59904022:59904292, 49043832:…\n  :chrX  => [72272603:72277210, 119786512:119791605, 77826515:77829079, 7924198…\n  :chr13 => [45337229:45341160, 98452159:98452832, 20403667:20525839, 45337254:…\n  :chr11 => [63974632:63976540, 809990:812856, 809978:812873, 16974643:16975031…\n  :chr22 => [41515512:41528974, 38483442:38483648, 35838275:35838675, 23894420:…\n  :chr19 => [49487627:49491841, 51989732:51989996, 41860787:41871398, 5690502:5…\n  :chr03 => [193658960:193694726, 135162156:135260466, 197954049:197955808, 191…\n  :chr05 => [170083215:170083368, 150444238:150445661, 40832456:40834607, 17814…\n  :chr06 => [31268757:31272069, 73517516:73521019, 73517515:73520059, 29942543:…\n  :chr20 => [62388308:62388509, 57408568:57409306, 21166171:21166419, 23633657:…\n  :chrY  => [13286599:13287476, 13286598:13287541, 13286599:13287542, 13286648:…\n  :chr04 => [102753381:102760907, 108620586:108625247, 108650646:108667810, 108…\n  :chr02 => [216499332:216501458, 216499269:216501462, 55232807:55235607, 20288…\n  :chr16 => [84565612:84566066, 2770366:2771406, 24094163:24220605, 56608601:56…\n  :chr09 => [19376352:19379531, 133019443:133021168, 19376255:19380216, 1102440…\n  :chr01 => [165655371:165655620, 84498368:84506172, 44777749:44778638, 2369261…\n\n\n\nWe will use the intervals on chromsome 21 for our timing benchmarks. The target for tests of intersection with a single target interval will be the last interval on chromosome 21 in “ex-rna.arrow”.\n\n\nrangevec21 = annorangevecs[:chr21]\nrnarange21 = rnarangevecs[:chr21]\ntarget = last(rnarange21)\n\n31659713:31668660"
  },
  {
    "objectID": "session2b-interval-overlap.html#intersecting-reference-ranges-with-a-target",
    "href": "session2b-interval-overlap.html#intersecting-reference-ranges-with-a-target",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Intersecting reference ranges with a target",
    "text": "Intersecting reference ranges with a target\n\nCreate a method to intersect a target interval with a Vector{UnitRange} returning the intersections as another Vector{UnitRange}.\nA common Julia programming idiom for such cases is to create two methods: one for intersect!, which modifies an argument that will hold the result, and one for intersect, which allocates the result then calls the intersect! method.\nFor the intersect! method we first empty! the result vector, which zeros the vector length but does not shrink the memory chunk allocated to the vector, then push! intersections onto it. If there are many calls to an intersect! method like this only a few will cause memory allocations.\nThe elements of our vectors of reference intervals, like rangevec21, are sorted by their first element but the last elements do not have any special relationships. The best we can do to determine all intersections is a sequential scan of the sorted vector of ranges with an early exit when last(target) < first(vectorelement).\n\n\nfunction intersect!(\n  result::Vector{UnitRange{T}},\n  target::AbstractUnitRange{<:Integer},\n  refs::Vector{UnitRange{T}}\n) where {T}\n  empty!(result)\n  target = eltype(refs)(target)  # coerce the type, if necessary\n  lastt = last(target)\n  for rng in refs\n    isect = intersect(target, rng)\n    !isempty(isect) && push!(result, isect)\n    lastt < first(rng) && break\n  end\n  return result\nend\nfunction intersect(target::AbstractUnitRange{<:Integer}, refs::Vector{UnitRange{T}}) where {T}\n  return intersect!(similar(refs, 0), target, refs)\nend\ncachedresult = intersect(target, rangevec21)  # will use for comparisons\n\n12-element Vector{UnitRange{Int32}}:\n 31659713:31659841\n 31659713:31659784\n 31659713:31659841\n 31659713:31660708\n 31661549:31661734\n 31663790:31663886\n 31664306:31664482\n 31666449:31666518\n 31666728:31667247\n 31667258:31667341\n 31667258:31667375\n 31668471:31668660\n\n\n\nresult = similar(rangevec21, 0)    # working storage\ncachedresult == intersect!(result, target, rangevec21)\n\ntrue"
  },
  {
    "objectID": "session2b-interval-overlap.html#create-dictionaries-of-rangetrees-and-intervaltrees",
    "href": "session2b-interval-overlap.html#create-dictionaries-of-rangetrees-and-intervaltrees",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Create dictionaries of RangeTrees and IntervalTrees",
    "text": "Create dictionaries of RangeTrees and IntervalTrees\n\nRangeTrees\n\nannorangetrees = Dict(k => RangeTree(v) for (k,v) in annorangevecs)\nrangetree21 = annorangetrees[:chr21]\nprint_tree(IndexNode(rangetree21); maxdepth=3)  # methods from AbstractTrees.jl\n\n(36058816:36058973, 46691226)\n├─ (25933816:25934366, 36058924)\n│  ├─ (13958116:13958185, 25928997)\n│  │  ├─ (7422603:7422701, 13954150)\n│  │  │  ⋮\n│  │  │  \n│  │  └─ (17604860:17604997, 25928997)\n│  │     ⋮\n│  │     \n│  └─ (32726772:32726917, 36058924)\n│     ├─ (29370497:29370973, 32702047)\n│     │  ⋮\n│     │  \n│     └─ (33602267:33602345, 36058924)\n│        ⋮\n│        \n└─ (43007491:43007618, 46691226)\n   ├─ (39422988:39423490, 43007515)\n   │  ├─ (37267238:37267301, 39423490)\n   │  │  ⋮\n   │  │  \n   │  └─ (41810154:41810466, 43007515)\n   │     ⋮\n   │     \n   └─ (44910284:44910415, 46691226)\n      ├─ (44133616:44134154, 44910372)\n      │  ⋮\n      │  \n      └─ (46112804:46112949, 46691226)\n         ⋮\n         \n\n\n\nRangeTrees.jl provides an implementation of interval trees using the augmented binary tree formulation.\nThis is a balanced, binary tree where nodes contain a UnitRange (sorted by first), the indices of the left and right subtrees, and maxlast, which is the maximum value of the last element in the ranges in the subtree rooted at the node.\nThe root of rangetree21 is the node at the median index of rangevec21, rounding the position up when the number of intervals is even.\n\n\nlength(rangevec21), midrange(eachindex(rangevec21))\n\n(6518, 3260)\n\n\n\nrangetree21[midrange(eachindex(rangetree21))]\n\nRangeNode{Int32}(36058816:36058973, 1630, 4890, 46691226)\n\n\n\nThe maxlast value for the root node must be the maximum last position of any of the ranges.\n\n\nmaximum(last.(rangevec21))\n\n46691226\n\n\n\nIt happens that this value is the same as the last position in the last range but that doesn’t have to be the case. The ranges are sorted by increasing first position, not by last position.\n\n\nlast(last(rangevec21))\n\n46691226\n\n\n\nintersect and intersect! methods are already defined for RangeTrees.\n\n\ncachedresult == intersect(target, rangetree21)\n\ntrue\n\n\n\ncachedresult == intersect!(result, target, rangetree21)\n\ntrue\n\n\n\n\nIntervalTrees\n\nNext create a dictionary with IntervalTree values. This is somewhat tedious to get right so we create a function to hide the details.\n\n\nfunction toitrees(rngdict::Dict{S, Vector{UnitRange{T}}}) where {S,T}\n  return Dict(k => IntervalTree{T, Interval{T}}(Interval.(v)) for (k,v) in rngdict)\nend\nannointvltrees = toitrees(annorangevecs)\nintvltree21 = annointvltrees[:chr21]\nshow(intvltree21)\n\nIntervalTree{\n\n\nInt32, Interval{Int32}}\n(5011799,5011874)\n(5012548,5012687)\n(5014386,5014471)\n⋮\n(46664295,46665117)\n(46664295,46665124)\n(46690764,46691226)\n\n\n\nCreating an intersect! method is also tedious because the package has its own Interval data type and it defines intersect(itr::IntervalTree, (frst, lst)) to return an iterator of Intervals in the tree, not the intersection\n\n\nInterval(target)\n\nInterval{Int32}\n(31659713,31668660)\n\n\n\nCreate an asrange method for the inverse mapping\n\n\nasrange(intvl::Interval) = first(intvl):last(intvl)\nasrange(Interval(target)) == target   # check it works\n\ntrue\n\n\n\nfunction intersect!(res::Vector{UnitRange{T}}, target::AbstractUnitRange, refs::IntervalTree{T}) where {T}\n  empty!(res)\n  firstt, lastt = first(target), last(target)\n  for isect in intersect(refs, (firstt, lastt))\n    push!(res, max(first(isect), firstt):min(last(isect), lastt))\n  end\n  return res\nend\ncachedresult == intersect!(result, target, intvltree21)\n\ntrue"
  },
  {
    "objectID": "session2b-interval-overlap.html#time-for-a-shootout",
    "href": "session2b-interval-overlap.html#time-for-a-shootout",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Time for a shootout",
    "text": "Time for a shootout\n\nVector{UnitRange}\n\n@benchmark intersect!(res, tar, ref) setup=(res = result; tar = target; ref = rangevec21)\n\n\nBenchmarkTools.Trial: 10000 samples with 9 evaluations.\n Range (min … max):  2.753 μs …   8.693 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     3.052 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   2.999 μs ± 372.286 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n  █       █▁                                                  ▁\n  █▄▂▂▆▅▅▇███▇▇▇▆▆▇▆▇█▇▆▆▇▆▇▇▇▅▆▆▆▆▆▅▆▆▆▆▅▆▄▅▅▅▄▃▅▅▄▄▄▄▄▃▅▃▄▂ █\n  2.75 μs      Histogram: log(frequency) by time      4.81 μs <\n Memory estimate: 0 bytes, allocs estimate: 0.\n\n\n\n\n@benchmark intersect(tar, ref) setup=(tar = target; ref = rangevec21)\n\n\nBenchmarkTools.Trial: 10000 samples with 9 evaluations.\n Range (min … max):  2.798 μs …  21.308 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     3.124 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   3.189 μs ± 498.981 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n  ▇▂█▇▅▃▃█▅▇█▅▅▄▃▃▂▂▂ ▁                                       ▂\n  ███████████████████████████▇▇█▇▇█▇█▇█▇▇▆▇▆▆▆▆▅▆▅▄▆▅▅▆▅▅▄▂▄▄ █\n  2.8 μs       Histogram: log(frequency) by time      5.22 μs <\n Memory estimate: 480 bytes, allocs estimate: 3.\n\n\n\n\n\nRangeTree\n\n@benchmark intersect!(res, tar, ref) setup=(res = result; tar = target; ref = rangetree21)\n\n\nBenchmarkTools.Trial: 10000 samples with 737 evaluations.\n Range (min … max):  180.642 ns … 488.369 ns  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     205.265 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   205.620 ns ±  20.211 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n    ▃▇         █▇▂                                               \n  ▂▄██▇▃▂▃▄▅▃▅████▄▃▄▅▇▄▂▃▃▂▁▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂\n  181 ns           Histogram: frequency by time          292 ns <\n Memory estimate: 0 bytes, allocs estimate: 0.\n\n\n\n\n@benchmark intersect(tar, ref) setup=(tar = target; ref = rangetree21)\n\n\nBenchmarkTools.Trial: 10000 samples with 460 evaluations.\n Range (min … max):  226.557 ns … 53.503 μs  ┊ GC (min … max):  0.00% … 99.28%\n Time  (median):     334.179 ns              ┊ GC (median):     0.00%\n Time  (mean ± σ):   374.590 ns ±  1.409 μs  ┊ GC (mean ± σ):  11.85% ±  3.13%\n  ▂█   ▇          ▅▅▇█▄█▇▄▅▄▁                                   \n  ██▂▅▆█▄▄▅▃▂▂▂▂▂▇████████████▅▄▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁ ▃\n  227 ns          Histogram: frequency by time          552 ns <\n Memory estimate: 480 bytes, allocs estimate: 3.\n\n\n\n\n\nIntervalTree\n\n@benchmark intersect!(res, tar, ref) setup=(res = result; tar = target; ref = intvltree21)\n\n\nBenchmarkTools.Trial: 10000 samples with 193 evaluations.\n Range (min … max):  491.052 ns …  1.117 μs  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     570.956 ns              ┊ GC (median):    0.00%\n Time  (mean ± σ):   588.447 ns ± 85.920 ns  ┊ GC (mean ± σ):  0.00% ± 0.00%\n  ▃▄▅▇▆▄▃▆▆▆█▇▆▅▅▅▄▃▃▂▂▂▁▁  ▁    ▁                             ▂\n  ████████████████████████████████▇████████▇███▇▇███▇▇▆▆▇█▆▇▇▇ █\n  491 ns        Histogram: log(frequency) by time       940 ns <\n Memory estimate: 80 bytes, allocs estimate: 3.\n\n\n\n\nIn what follows we will use the RangeTree method for intersect! to obtain the intersections."
  },
  {
    "objectID": "session2b-interval-overlap.html#determining-coverage",
    "href": "session2b-interval-overlap.html#determining-coverage",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Determining coverage",
    "text": "Determining coverage\n\nThe coverage of a target by a set of reference intervals is the proportion of the base pairs in the target that intersect with one or more of the reference intervals.\nWe need to somehow count the number of elements in the union of the intervals returned from intersect!.\nThis could be done using the union! method for a BitSet but that approach has two problems: it is comparatively slow and, in Julia versions up to 1.8.0-rc1, it can be wrong.\n\n\n\n\n\n\n\nNote\n\n\n\n\nWhile creating these notes we discovered a bug in the union! method for a BitSet and a UnitRange.\nThere was a PR to fix it the next morning.\nVersions of Julia prior to 1.8.0-rc2 can (and probably will) return incorrect values of coverage.\nReplacing union!(bs, isect) by union!(bs, BitSet(isect)) avoids this “infelicity” at the expense of more memory usage and compute time.\n\n\n\n\nThere is a better method that takes advantage of the intersecting intervals being produced in sorted order by first\nThe idea is to “keep moving the goalposts”. When evaluating the coverage count, add the length of the current reference interval’s intersection with only the part to the right of what has already been covered.\n\n\nfunction coveragecount(\n  target::AbstractUnitRange,\n  isects::Vector{UnitRange{T}}\n) where {T}\n  goalposts = target\n  rightpost = last(goalposts)\n  coverage = 0\n  for isect in isects\n    coverage += length(intersect(goalposts, isect))\n    goalposts = (last(isect) + one(T)):rightpost\n  end\n  return coverage\nend\ncoveragecount(target, cachedresult)\n\n2411"
  },
  {
    "objectID": "session2b-interval-overlap.html#iterating-over-a-set-of-targets",
    "href": "session2b-interval-overlap.html#iterating-over-a-set-of-targets",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Iterating over a set of targets",
    "text": "Iterating over a set of targets\n\nfunction overlaps(targets::Vector{UnitRange{T}}, refs::RangeTree{T}) where {T}\n  ntargets = length(targets)\n  nover = sizehint!(Int[], ntargets)\n  covcount = sizehint!(T[], ntargets)\n  result = UnitRange{T}[]\n  for tar in targets\n    push!(nover, length(intersect!(result, tar, refs)))\n    push!(covcount, coveragecount(tar, result))\n  end\n  DataFrame(targets = targets, nover = nover, covcount = covcount)\nend\noverlaps(rnarange21, rangetree21)\n\n\n51,720 rows × 3 columnstargetsnovercovcountUnitRang…Int64Int3218212585:8212728114028207701:825238911337438256795:82569411139446189146:461895033358546188448:461886115164614371115:14371404129078439844:8439977113285116341:511882641027941427205:414477152951901039342315:393427663452118256801:825694611331234710834:34711564001342381884:42390040142632148256806:825694511281532734855:3273520942131618857745:1885848214981741440888:414592122037691833567155:335774933347031914485242:144874442873208212141:8212352002144805624:448060011378226641565:664244900238439843:843998311332433903507:3390364141352533903459:33914500202079268253486:8253820002741446033:4145918391979288395617:839576811432925562141:2557423045403025880810:258816236814⋮⋮⋮⋮\n\n\n\n@benchmark overlaps(targets, refs) setup=(targets = rnarange21; refs = rangetree21)\n\n\nBenchmarkTools.Trial: 334 samples with 1 evaluation.\n Range (min … max):  13.650 ms …  17.696 ms  ┊ GC (min … max): 0.00% … 9.74%\n Time  (median):     14.897 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   14.962 ms ± 598.862 μs  ┊ GC (mean ± σ):  0.07% ± 0.78%\n              ▄ ▄▄▆▅██▄▆▅▄▇▆▇▄▆▆▁▅▃ ▃▃                          \n  ▃▁▁▆▁▅▅▅▆▇▅▅█▄███████████████████▄██▇▇█▃█▄▆▅▄▆▄▄▄▇▃▁▅▁▃▃▁▁▁▄ ▅\n  13.7 ms         Histogram: frequency by time         16.7 ms <\n Memory estimate: 1.58 MiB, allocs estimate: 41."
  },
  {
    "objectID": "session2b-interval-overlap.html#the-whole-shootin-match",
    "href": "session2b-interval-overlap.html#the-whole-shootin-match",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "The whole shootin’ match",
    "text": "The whole shootin’ match\n\nThe computations on different chromosome are independent of each other and can be assigned to different threads when Julia is started with multiple threads.\n\n\nfunction overlaps(\n  targets::Dict{Symbol, Vector{UnitRange{T}}},\n  refdict::Dict{Symbol, RangeTree{T}}\n) where {T}\n  value = Dict{Symbol, DataFrame}()\n  @sync for k in intersect(keys(targets), keys(refdict))\n    Threads.@spawn value[k] = overlaps(targets[k], refdict[k])\n  end\n  return value\nend\nbigresult = overlaps(rnarangevecs, annorangetrees);\nbigresult[:chrY]\n\n\n89 rows × 3 columnstargetsnovercovcountUnitRang…Int64Int32113286599:132874761741213286598:132875411741313286599:132875421741413286648:132875091731513286679:13287469170065793260:5793463116475793274:57934721173810200166:102003081141913287196:1328754111831018992142:18992375001118992104:18992424001224362036:24362135001313287300:132875431791418992170:18992298001513286570:1328746917411613286566:1328741317411713287043:1328744013361811336248:114425841542841913286619:1328746717412013286571:1328754217412113286659:1328754717202213286587:132875431741235793255:579346711682413287260:1328754211192513286762:1328740816172613286725:132875221654275337673:533810613622813286617:1328754317412918992107:1899266612003013286699:132874351680⋮⋮⋮⋮\n\n\n\n@benchmark overlaps(targets, refs) setup=(targets = rnarangevecs; refs = annorangetrees)\n\n\nBenchmarkTools.Trial: 9 samples with 1 evaluation.\n Range (min … max):  505.923 ms … 642.621 ms  ┊ GC (min … max): 0.00% … 0.77%\n Time  (median):     550.828 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   560.387 ms ±  43.323 ms  ┊ GC (mean ± σ):  0.10% ± 0.26%\n  █     █ █       █   █         █   █     █                   █  \n  █▁▁▁▁▁█▁█▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁▁▁▁▁▁█▁▁▁█▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁\n  506 ms           Histogram: frequency by time          643 ms <\n Memory estimate: 143.21 MiB, allocs estimate: 1172."
  },
  {
    "objectID": "session2b-interval-overlap.html#conclusions",
    "href": "session2b-interval-overlap.html#conclusions",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Conclusions",
    "text": "Conclusions\n\nThe ability to work in the REPL (or VS Code or Jupyter notebooks) encourages iterative refinement of algorithms.\n“Trust but verify” - when making a change or introducing new methods it helps to have results from previous methods for comparison. In general, continuous integration (CI) testing is straightforward for Julia packages and is strongly encouraged.\nThere are many tools for benchmarking function execution or storage allocation, allowing a developer to concentrate on where the “real problem” is.\nIn certain cases, enhancements like multi-threading can be achieved with very little effort."
  },
  {
    "objectID": "session2b-interval-overlap.html#version-information",
    "href": "session2b-interval-overlap.html#version-information",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Version information",
    "text": "Version information\n\nversioninfo()\n\nJulia Version 1.8.0-rc1\nCommit 6368fdc656 (2022-05-27 18:33 UTC)\nPlatform Info:\n  OS: Linux (x86_64-pc-linux-gnu)\n  CPU: 8 × 11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, tigerlake)\n  Threads: 4 on 8 virtual cores"
  },
  {
    "objectID": "session4-exercise.html",
    "href": "session4-exercise.html",
    "title": "Hands-on exercise",
    "section": "",
    "text": "Instructions: Participants will translate their R/python script to Julia with assistance from the workshop presenters and TAs. After the 60 minutes, one or two volunteers will share their script to the group.\n\nChecklist\n\nDo you have Julia installed? If not, go to the getting started notes\nDo you have your project folder and installed dependencies? If not, go to the getting started nodes\nDo you have your data in your project folder?\nHave you selected an editor to use (VSCode, Emacs, Jupyter notebooks,…)? Check out the available options in the Julia website\n\nYou are ready to start writing Julia code! You can start with a simple .jl file, or you could try with a jupyter notebook or a .qmd file."
  },
  {
    "objectID": "session5-other-tools.html#communication-with-other-systems-julia-interoperability",
    "href": "session5-other-tools.html#communication-with-other-systems-julia-interoperability",
    "title": "Session 5: Other tools for Data Science",
    "section": "Communication with other systems: Julia interoperability",
    "text": "Communication with other systems: Julia interoperability\nJuliaInterop\n\nNote: Both RCall and PyCall are written 100% julia\n\nRCall\nDocumentation\nSwitching between julia and R using $:\njulia> using RCall\n\njulia> foo = 1\n1\n\nR> x <- $foo\n\nR> x\n[1] 1\nMacros @rget and @rput:\njulia> z = 1\n1\n\njulia> @rput z\n1\n\nR> z\n[1] 1\n\nR> r = 2\n\njulia> @rget r\n2.0\n\njulia> r\n2.0\nR\"\" string macro:\njulia> R\"rnorm(10)\"\nRObject{RealSxp}\n [1]  0.9515526 -2.1268329 -1.1197652 -1.3737837 -0.5308834 -0.1053615\n [7]  1.0949319 -0.8180752  0.7316163 -1.3735100\nLarge chunk of code:\njulia> y=1\n1\n\njulia> R\"\"\"\n       f<-function(x,y) x+y\n       ret<- f(1,$y)\n       \"\"\"\nRObject{RealSxp}\n[1] 2\n\nA small example from this blog\nSimulate data\njulia> using Random\n\njulia> Random.seed!(1234)\nMersenneTwister(1234)\n\njulia> X = randn(3,2)\n3×2 Matrix{Float64}:\n  0.867347  -0.902914\n -0.901744   0.864401\n -0.494479   2.21188\n\njulia> b = reshape([2.0, 3.0], 2,1)\n2×1 Matrix{Float64}:\n 2.0\n 3.0\n\njulia> y = X * b + randn(3,1)\n3×1 Matrix{Float64}:\n -0.4412351955236954\n  0.5179809120122916\n  6.149009488103242\nFit a model\njulia> @rput y\n3×1 Matrix{Float64}:\n -0.4412351955236954\n  0.5179809120122916\n  6.149009488103242\n\njulia> @rput X\n3×2 Matrix{Float64}:\n  0.867347  -0.902914\n -0.901744   0.864401\n -0.494479   2.21188\n\njulia> R\"mod <- lm(y ~ X-1)\"\nRObject{VecSxp}\n\nCall:\nlm(formula = y ~ X - 1)\n\nCoefficients:\n   X1     X2  \n2.867  3.418 \n\njulia> R\"summary(mod)\"\nRObject{VecSxp}\n\nCall:\nlm(formula = y ~ X - 1)\n\nResiduals:\n       1        2        3 \n0.158301 0.148692 0.006511 \n\nCoefficients:\n   Estimate Std. Error t value Pr(>|t|)  \nX1   2.8669     0.2566   11.17   0.0568 .\nX2   3.4180     0.1359   25.15   0.0253 *\n---\nSignif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n\nResidual standard error: 0.2173 on 1 degrees of freedom\nMultiple R-squared:  0.9988,    Adjusted R-squared:  0.9963 \nF-statistic: 404.8 on 2 and 1 DF,  p-value: 0.03512\n\njulia> R\"plot(X[,1],y)\"\n\n\n\nPyCall\nDocumentation\nNote that (@v1.8) pkg> add PyCall will use the Conda.jl package to install a minimal Python distribution (via Miniforge) that is private to Julia (not in your PATH).\nWe need to make sure that which conda points at the conda folder inside .julia, so we need to put ~/.julia/conda/3/bin early on the PATH. In Mac zsh, we need to add export PATH=~/.julia/conda/3/bin:$PATH in the ~/.zshrc file. (Those who prefer not to conda-ize their entire environment may instead choose just to link ~/.julia/conda/3/bin/{conda,jupyter,python,python3} somewhere on their existing path, such as ~/bin.)\nSimple example:\nusing PyCall\nmath = pyimport(\"math\")\nmath.sin(math.pi / 4)\npy\"...\" evaluates \"...\" as Python code:\npy\"\"\"\nimport numpy as np\n\ndef sinpi(x):\n    return np.sin(np.pi * x)\n\"\"\"\npy\"sinpi\"(1)\n\n\nMore on Julia/python connectivity\n\nThe pyjulia module allows you to call Julia directly from Python\nCheck out the packages in JuliaPy"
  },
  {
    "objectID": "session5-other-tools.html#package-system",
    "href": "session5-other-tools.html#package-system",
    "title": "Session 5: Other tools for Data Science",
    "section": "Package system",
    "text": "Package system\n\nStarting on Julia 1.6, precompilation is much faster\nMany changes under the hood that allow things to work faster and more smoothly\nA local environment can be established and preserved with Project.toml and Manifest.toml files.\nUse of Artifacts.toml allows for binary dependencies\n\n\nLandscape of Julia packages for biology\n\nBioJulia is a combination of Julia packages for biology applications.\nJulia for Biologists is an arxiv paper the features that make Julia a perfect language for bioinformatics and computational biology.\nList of useful packages by SMLP2022"
  },
  {
    "objectID": "session5-other-tools.html#plotting",
    "href": "session5-other-tools.html#plotting",
    "title": "Session 5: Other tools for Data Science",
    "section": "Plotting",
    "text": "Plotting\n\nMakie ecosystem\nPlots.jl\nOther graphics packages available in Julia"
  },
  {
    "objectID": "session5-other-tools.html#performance-tips",
    "href": "session5-other-tools.html#performance-tips",
    "title": "Session 5: Other tools for Data Science",
    "section": "Performance tips",
    "text": "Performance tips\nSee more in Julia docs\n\n@time to measure performance\njulia> x = rand(1000);\n\njulia> function sum_global()\n           s = 0.0\n           for i in x\n               s += i\n           end\n           return s\n       end;\n\njulia> @time sum_global()  ## function gets compiled\n  0.017705 seconds (15.28 k allocations: 694.484 KiB)\n496.84883432553846\n\njulia> @time sum_global()\n  0.000140 seconds (3.49 k allocations: 70.313 KiB)\n496.84883432553846\n\n\nBreak functions into multiple definitions\nThe function\nusing LinearAlgebra\n\nfunction mynorm(A)\n    if isa(A, Vector)\n        return sqrt(real(dot(A,A)))\n    elseif isa(A, Matrix)\n        return maximum(svdvals(A))\n    else\n        error(\"mynorm: invalid argument\")\n    end\nend\nshould really be written as\nnorm(x::Vector) = sqrt(real(dot(x, x)))\nnorm(A::Matrix) = maximum(svdvals(A))\nto allow the compiler to directly call the most applicable code.\n\nMultiple dispatch\n\nThe choice of which method to execute when a function is applied is called dispatch\nJulia allows the dispatch process to choose based on the number of arguments given, and on the types of all of the function’s arguments\nThis is denoted multiple dispatch\nThis is different than traditional object-oriented languages, where dispatch occurs based only on the first argument\n\njulia> f(x::Float64, y::Float64) = 2x + y\nf (generic function with 1 method)\n\njulia> f(2.0, 3.0)\n7.0\n\njulia> f(2.0, 3)\nERROR: MethodError: no method matching f(::Float64, ::Int64)\nClosest candidates are:\n  f(::Float64, !Matched::Float64) at none:1\nCompare to\njulia> f(x::Number, y::Number) = 2x + y\nf (generic function with 2 methods)\n\njulia> f(2.0, 3.0)\n7.0\n\njulia> f(2, 3.0)\n7.0\n\njulia> f(2.0, 3)\n7.0\n\njulia> f(2, 3)\n7\n\n\n\nProfiling\nRead more in Julia docs.\njulia> function myfunc()\n           A = rand(200, 200, 400)\n           maximum(A)\n       end\n\njulia> myfunc() # run once to force compilation\n\njulia> using Profile\n\njulia> @profile myfunc()\n\njulia> Profile.print()\nTo see the profiling results, there are several graphical browsers (see Julia docs).\n\n\nOther packages for performance\n\nBenchmarkTools.jl: performance tracking of Julia code\nTraceur.jl: You run your code, it tells you about any obvious performance traps"
  },
  {
    "objectID": "session5-other-tools.html#literate-programming",
    "href": "session5-other-tools.html#literate-programming",
    "title": "Session 5: Other tools for Data Science",
    "section": "Literate programming",
    "text": "Literate programming\n\nquarto.org. These notes are rendered with quarto!\nJupyter\nPluto.jl\nWeave.jl package provides “Julia markdown” and also provides support for converting between jmd files and Jupyter notebooks.\nLiterate.jl is a simple package for literate programming (i.e. programming where documentation and code are “woven” together) and can generate Markdown, plain code and Jupyter notebook output.\nDocumenter.jl is the standard tool for building webpages from Julia documentation\nBooks.jl is a package designed to offer somewhat similar functionality to the bookdown package in R."
  },
  {
    "objectID": "session6-conclusions.html",
    "href": "session6-conclusions.html",
    "title": "Session 6: Conclusions",
    "section": "",
    "text": "Julia provides many advantages to data science programmers especially those creating programs that need to be efficient and that will be shared with the scientific community\nJulia allows programmers to easily write good performant code and avoid the two language problem\n\nAmong the main Julia tools, we focused on five:\n\n\n\nArrow.jl: memory, layout, data frame, binary form. The binary form allows for cross-platform use (julia, R, python). Need to be careful going from Julia to R.\nTables.jl: generic idea of data table; row oriented (vector of named tuples) or column oriented (named tuple of vectors).\nDataFrames.jl: cheatsheet similar to tidyverse.\n\n\n\n\n\nMixedModels.jl: 100% julia package\n\n\n\n\n\nRCall.jl: 100% julia package\nPyCall.jl: 100% julia package\n\n\n\n\n\nWith Julia 1.7+, precompilation is done when the package is added\nMultiple biology-oriented packages in BioJulia\n\n\n\n\n\nPerformance tips\nProfiling\n\n\n\n\n\nMakie ecosystem\nPlots.jl\n\n\n\n\n\nquarto.org. These notes are rendered with quarto!\nJupyter\nPluto.jl"
  },
  {
    "objectID": "session5-other-tools.html",
    "href": "session5-other-tools.html",
    "title": "Session 5: Other tools for Data Science",
    "section": "",
    "text": "Data tools with Arrow.jl and Tables.jl\nModel fitting with MixedModels.jl"
  },
  {
    "objectID": "session2b-interval-overlap.html#creating-dictionaries-of-vectorunitrange",
    "href": "session2b-interval-overlap.html#creating-dictionaries-of-vectorunitrange",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "Creating dictionaries of Vector{UnitRange}",
    "text": "Creating dictionaries of Vector{UnitRange}\n\nA UnitRange, like 2:10, includes the end points (accessed as first and last).\n\n\ntypeof(2:10)\n\nUnitRange{Int64}\n\n\n\nlength(2:10)\n\n9\n\n\n\nThe positions in the start and stop columns in a .bed are not both included in the interval represented. The positions correspond to the interval start:(stop - 1) as 0-based positions or (start + 1):stop in 1-based positions.\nIt doesn’t matter which one we use as long as we are consistent.\nWe will start counting from 1, just like world’s greatest expert on counting does.\nWe wrap this conversion in a utility function to help ensure consistency.\n\n\nasrange(start, stop) = (start + one(start)):stop\n\nasrange (generic function with 2 methods)\n\n\n\n\n\n\n\n\nNote\n\n\n\none(x) is used instead of the literal 1 in asrange to preserve the integer type (see also ?oneunit, which is slighly more general).\n\nst = Int32(2314)\ntypeof(st + 1)       # type gets promoted to Int64\n\nInt64\n\n\n\ntypeof(st + one(st)) # type not promoted\n\nInt32\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis method definition uses the compact “one-liner” form.\n\n\n\nfunction datatable(fnroot::AbstractString)\n  return DataFrame(Arrow.Table(joinpath(datadir, \"$fnroot.arrow\")))\nend\nfunction chromodict(df::DataFrame; sorted::Bool=false)\n  T = eltype(df.start)\n  vtype = Vector{UnitRange{T}}\n  dict = Dict{Symbol, vtype}()\n  for r in rowtable(sorted ? sort(df) : df)\n    (; chromo, start, stop) = r\n    push!(get!(dict, Symbol(chromo), vtype()), asrange(start, stop))\n  end\n  return dict\nend\nannorangevecs = chromodict(datatable(\"ex-anno\"); sorted=true)\n\nDict{Symbol, Vector{UnitRange{Int32}}} with 24 entries:\n  :chr21 => [5011799:5011874, 5012548:5012687, 5014386:5014471, 5016935:5017145…\n  :chr15 => [19878555:19878668, 19878831:19879004, 19881201:19881307, 19882277:…\n  :chr10 => [14061:14299, 14138:14299, 14497:14604, 16502:16544, 44712:44901, 4…\n  :chr17 => [64099:65736, 65830:65887, 71366:71556, 75814:75878, 76723:76866, 8…\n  :chr07 => [12704:12822, 19018:19172, 19619:19895, 20834:21029, 24314:24365, 2…\n  :chr14 => [16057472:16057622, 18333726:18333900, 18333826:18333896, 18337973:…\n  :chr08 => [64091:64175, 64269:64320, 72601:72673, 72617:72701, 78905:79244, 7…\n  :chr12 => [12310:12358, 12740:12824, 13102:13201, 13370:13501, 14522:14944, 1…\n  :chr18 => [11103:11595, 11191:11595, 13152:13354, 14195:14653, 14490:14653, 1…\n  :chrX  => [253743:253846, 254937:255091, 276322:276394, 276324:276394, 276353…\n  :chr13 => [18174010:18174103, 18174442:18174512, 18176018:18176170, 18177555:…\n  :chr11 => [75780:76143, 86649:87586, 112967:113111, 113116:113174, 121258:121…\n  :chr22 => [10736171:10736283, 10939388:10939423, 10940597:10940707, 10941691:…\n  :chr03 => [23757:23812, 23968:24501, 53348:53692, 54293:54346, 195758:195914,…\n  :chr19 => [60951:61894, 62113:66524, 63821:64213, 65051:65226, 65822:66047, 6…\n  :chr05 => [58198:58915, 92151:92276, 113251:113448, 139483:140716, 140258:140…\n  :chr06 => [95124:95454, 105919:106856, 131910:132117, 140211:140379, 142272:1…\n  :chr20 => [87250:87359, 87710:87767, 96005:96533, 96005:97094, 142369:142686,…\n  :chrY  => [2784749:2784853, 2786855:2787699, 2789827:2790328, 2827982:2828218…\n  :chr04 => [49096:49956, 49554:50124, 53285:53491, 53286:53491, 53295:53491, 5…\n  :chr02 => [38814:41627, 41220:41627, 41221:41627, 42809:42952, 45440:46385, 4…\n  :chr01 => [11869:12227, 12010:12057, 12179:12227, 12613:12697, 12613:12721, 1…\n  :chr09 => [12134:12190, 12291:12340, 12726:12834, 13088:13157, 13338:13487, 1…\n  :chr16 => [11555:11908, 11861:11908, 12294:12378, 12294:12402, 12663:12733, 1…\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe call get!(dict, Symbol(chromo), vtype()) in chromodict returns dict[Symbol(chromo)] or the default value, which is an empty Vector{UnitRange{T}}. For the case of the default, it also installs that key/value pair in dict.\n\n\n\nDo the same for the \"ex-rna\" intervals (without sorting).\n\n\nrnarangevecs = chromodict(datatable(\"ex-rna\"))\n\nDict{Symbol, Vector{UnitRange{Int32}}} with 24 entries:\n  :chr21 => [8212585:8212728, 8207701:8252389, 8256795:8256941, 46189146:461895…\n  :chr15 => [55181315:55196932, 82536758:82540239, 82372221:82372895, 44711528:…\n  :chr10 => [80155591:80169336, 50305605:50306118, 96750280:96750926, 97426203:…\n  :chr17 => [76270412:76271290, 16031524:16031722, 1857276:1857405, 29551138:29…\n  :chr07 => [101239612:101245071, 5527161:5529285, 73569680:73572887, 5527151:5…\n  :chr14 => [105487209:105488788, 98972821:98973068, 105854220:105855113, 49583…\n  :chr12 => [56712431:56713192, 56712433:56724523, 22046215:22065551, 106973811…\n  :chr08 => [98041721:98045534, 144789769:144792143, 78732767:78733310, 9804172…\n  :chr18 => [55225981:55226732, 59903931:59904296, 59904022:59904292, 49043832:…\n  :chrX  => [72272603:72277210, 119786512:119791605, 77826515:77829079, 7924198…\n  :chr13 => [45337229:45341160, 98452159:98452832, 20403667:20525839, 45337254:…\n  :chr11 => [63974632:63976540, 809990:812856, 809978:812873, 16974643:16975031…\n  :chr22 => [41515512:41528974, 38483442:38483648, 35838275:35838675, 23894420:…\n  :chr19 => [49487627:49491841, 51989732:51989996, 41860787:41871398, 5690502:5…\n  :chr03 => [193658960:193694726, 135162156:135260466, 197954049:197955808, 191…\n  :chr05 => [170083215:170083368, 150444238:150445661, 40832456:40834607, 17814…\n  :chr06 => [31268757:31272069, 73517516:73521019, 73517515:73520059, 29942543:…\n  :chr20 => [62388308:62388509, 57408568:57409306, 21166171:21166419, 23633657:…\n  :chrY  => [13286599:13287476, 13286598:13287541, 13286599:13287542, 13286648:…\n  :chr04 => [102753381:102760907, 108620586:108625247, 108650646:108667810, 108…\n  :chr02 => [216499332:216501458, 216499269:216501462, 55232807:55235607, 20288…\n  :chr16 => [84565612:84566066, 2770366:2771406, 24094163:24220605, 56608601:56…\n  :chr09 => [19376352:19379531, 133019443:133021168, 19376255:19380216, 1102440…\n  :chr01 => [165655371:165655620, 84498368:84506172, 44777749:44778638, 2369261…\n\n\n\nWe will use the intervals on chromsome 21 for our timing benchmarks. The target for tests of intersection with a single target interval will be the last interval on chromosome 21 in “ex-rna.arrow”.\n\n\nrangevec21 = annorangevecs[:chr21]\nrnarange21 = rnarangevecs[:chr21]\ntarget = last(rnarange21)\n\n31659713:31668660"
  },
  {
    "objectID": "session2b-interval-overlap.html#rangetrees",
    "href": "session2b-interval-overlap.html#rangetrees",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "RangeTrees",
    "text": "RangeTrees\n\nRangeTrees.jl provides an implementation of interval trees using the augmented binary tree formulation.\n\n\nannorangetrees = Dict(k => RangeTree(v) for (k,v) in annorangevecs)\nrangetree21 = annorangetrees[:chr21]\nprint_tree(IndexNode(rangetree21); maxdepth=3)  # methods from AbstractTrees.jl\n\n(36058816:36058973, 46691226)\n├─ (25933816:25934366, 36058924)\n│  ├─ (13958116:13958185, 25928997)\n│  │  ├─ (7422603:7422701, 13954150)\n│  │  │  ⋮\n│  │  │  \n│  │  └─ (17604860:17604997, 25928997)\n│  │     ⋮\n│  │     \n│  └─ (32726772:32726917, 36058924)\n│     ├─ (29370497:29370973, 32702047)\n│     │  ⋮\n│     │  \n│     └─ (33602267:33602345, 36058924)\n│        ⋮\n│        \n└─ (43007491:43007618, 46691226)\n   ├─ (39422988:39423490, 43007515)\n   │  ├─ (37267238:37267301, 39423490)\n   │  │  ⋮\n   │  │  \n   │  └─ (41810154:41810466, 43007515)\n   │     ⋮\n   │     \n   └─ (44910284:44910415, 46691226)\n      ├─ (44133616:44134154, 44910372)\n      │  ⋮\n      │  \n      └─ (46112804:46112949, 46691226)\n         ⋮\n         \n\n\n\nA RangeTree represents a balanced, binary tree of ranges, sorted by first, in a Vector{RangeNode}. Each RangeNode contains a UnitRange, the indices of the left and right subtrees, and maxlast, which is the maximum value of the last element in the ranges of the subtree rooted at the node.\nEvaluating and storing maxlast in the nodes allows for overlap searchs to be truncated at nodes for which maxlast < first(target). The sorting by first allows for skipping the right subtree whenever last(target) < first(thisnode) (as in the overlaps method for Vector{UnitRange}).\nThe root of rangetree21 is the node at the median index of rangevec21, rounding the position up when the length of the vector of nodes is even.\n\n\nlength(rangevec21), midrange(eachindex(rangevec21))\n\n(6518, 3260)\n\n\n\nrangetree21[midrange(eachindex(rangetree21))]\n\nRangeNode{Int32}(36058816:36058973, 1630, 4890, 46691226)\n\n\n\nThe maxlast value for the root node must be the maximum last position of any of the ranges.\n\n\nmaximum(last.(rangevec21))\n\n46691226\n\n\n\nIt happens that this value is the same as the last position in the last range but that doesn’t have to be the case. The ranges are sorted by increasing first position, not by last position.\n\n\nlast(last(rangevec21))\n\n46691226\n\n\n\nintersect and intersect! methods are already defined in RangeTrees.jl.\nCheck that their results agree with the saved result.\n\n\nsavedresult == intersect(target, rangetree21)\n\ntrue\n\n\n\nsavedresult == intersect!(result, target, rangetree21)\n\ntrue"
  },
  {
    "objectID": "session2b-interval-overlap.html#intervaltrees",
    "href": "session2b-interval-overlap.html#intervaltrees",
    "title": "Session 2b: Determining Interval Overlap",
    "section": "IntervalTrees",
    "text": "IntervalTrees\n\nCreate a dictionary of IntervalTrees. It is somewhat tedious to get the type of the result correct and we create a function to hide the details.\n\n\nfunction toitrees(rngdict::Dict{S, Vector{UnitRange{T}}}) where {S,T}\n  return Dict(\n    k => IntervalTree{T, Interval{T}}(Interval.(v)) for (k,v) in rngdict\n  )\nend\nannointvltrees = toitrees(annorangevecs)\nintvltree21 = annointvltrees[:chr21]\nshow(intvltree21)\n\nIntervalTree{Int32, Interval{Int32}}\n(5011799,5011874)\n(5012548,5012687)\n(5014386,5014471)\n⋮\n(46664295,46665117)\n(46664295,46665124)\n(46690764,46691226)\n\n\n\nCreating an intersect! method is also tedious because the package has its own Interval data type and defines intersect(itr::IntervalTree, (frst, lst)) to return an iterator of Intervals in the tree, not the intersection\n\n\nInterval(target)\n\nInterval{Int32}\n(31659713,31668660)\n\n\n\nCreate an asrange method for the inverse mapping\n\n\nasrange(intvl::Interval) = first(intvl):last(intvl)\nasrange(Interval(target)) == target  # check it\n\ntrue\n\n\n\nfunction intersect!(\n  res::Vector{UnitRange{T}},\n  target::AbstractUnitRange,\n  refs::IntervalTree{T}\n) where {T}\n  empty!(res)\n  firstt, lastt = first(target), last(target)\n  for isect in intersect(refs, (firstt, lastt))\n    push!(res, max(first(isect), firstt):min(last(isect), lastt))\n  end\n  return res\nend\nsavedresult == intersect!(result, target, intvltree21) # check it\n\ntrue"
  },
  {
    "objectID": "session2a-tables-and-arrow.html#extract-the-files-of-interest-if-not-already-present",
    "href": "session2a-tables-and-arrow.html#extract-the-files-of-interest-if-not-already-present",
    "title": "Session 2a: Data Tables and Arrow files",
    "section": "Extract the files of interest (if not already present)",
    "text": "Extract the files of interest (if not already present)\n\nisdir(datadir) || mkdir(datadir)\nbedfnms = joinpath.(datadir, [\"ex-anno.bed\", \"ex-rna.bed\"])\ntoextract = filter(!isfile, bedfnms)  # don't overwrite existing files\nif !isempty(toextract)\n  tmpdir = gzopen(tarball, \"r\") do io\n    Tar.extract(h -> in(h.path, toextract), io)\n  end\n  for pathnm in toextract\n    mv(joinpath(tmpdir, pathnm), pathnm; force=true)\n  end\nend\nfilter(endswith(\".bed\"), readdir(datadir))\n\n2-element Vector{String}:\n \"ex-anno.bed\"\n \"ex-rna.bed\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe call joinpath.(datadir, [\"ex-anno.bed\", \"ex-rna.bed\"]) is an example of dot broadcasting\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe expression h -> in(h.path, toextract) defines an anonymous function, in the “stabby lambda” syntax, to be used as a predicate in Tar.extract.\n\nmethods(Tar.extract)\n\n# 4 methods for generic function extract: extract(predicate::Function, tarball::Union{Base.AbstractCmd, AbstractString, IO}) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:218  extract(predicate::Function, tarball::Union{Base.AbstractCmd, AbstractString, IO}, dir::Union{Nothing, AbstractString}; skeleton, copy_symlinks, set_permissions) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:218  extract(tarball::Union{Base.AbstractCmd, AbstractString, IO}) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:248  extract(tarball::Union{Base.AbstractCmd, AbstractString, IO}, dir::Union{Nothing, AbstractString}; skeleton, copy_symlinks, set_permissions) in Tar at /home/bates/.julia/juliaup/julia-1.8.0-rc1+0~x64/share/julia/stdlib/v1.8/Tar/src/Tar.jl:248 \n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe ‘do/end’ block is yet another way of writing an anonymous function passed as the first argument in the call to gzopen, even though it occurs after that call in the code.\n\nmethods(gzopen)\n\n# 4 methods for generic function gzopen: gzopen(fname::AbstractString) in GZip at /home/bates/.julia/packages/GZip/JNmGn/src/GZip.jl:264  gzopen(fname::AbstractString, gzmode::AbstractString) in GZip at /home/bates/.julia/packages/GZip/JNmGn/src/GZip.jl:263  gzopen(fname::AbstractString, gzmode::AbstractString, gz_buf_size::Integer) in GZip at /home/bates/.julia/packages/GZip/JNmGn/src/GZip.jl:236  gzopen(f::Function, args...) in GZip at /home/bates/.julia/packages/GZip/JNmGn/src/GZip.jl:267 \n\n\nThe effect is to open the file as a uncompressed stream, process the stream in this anonymous function, then close the stream.\n\n\n\n\n\n\n\n\nNote\n\n\n\nBecause Tar.extract is conservative about overwriting files and requires that the directory into which the files are extracted be empty, we extract to a freshly-created temporary directory then move the files to the desired location.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nIt is common for packages providing utilities to avoid name conflicts by not exporting any names from their namespace (or Module).\nThe fully qualified name, Tar.extract, can always be used - similar to Python naming conventions.\nIf a package exports a name, say foo, then after the using FooPackage directive, the unqualified name foo can be used.\nThe varinfo function provides a listing of the names exported by a Package (formally the package’s Module).\nCompare the result below with that of, say, varinfo(DataFrames).\n\nvarinfo(Tar)\n\n\n\nname\nsize\nsummary\n\n\n\n\nTar\n856.891 KiB\nModule"
  }
]