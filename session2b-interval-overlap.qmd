---
title: "Session 2b: Determining Interval Overlap"
author: "Douglas Bates and Claudia Solis-Lemus"
jupyter: julia-1.8
---

## Load packages to be used

```{julia}
#| code-fold: show
using Arrow          # Arrow storage and file format
using BenchmarkTools # tools for benchmarking code
using DataFrames     # versatile tabular data format
using IntervalTrees  # interval trees from BioJulia
using Random         # random number generation tools
using RangeTrees     # a bespoke implementation of interval trees
using Tables         # row- or column-oriented tabular data

import Base.intersect  # will create new methods for these generics
import Base.intersect!

datadir = "biofast-data-v1";
```

# Strategy for computing overlaps

  - Split the data in the Arrow data tables by chromosome tag and convert the `start-stop` pairs to a `Vector{UnitRange}`.  For the reference intervals, sort the vectors by increasing `first` value.
  - For the reference intervals create two other dictionaries whose values are [RangeTrees](https://github.com/dmbates/RangeTrees.jl) and [IntervalTrees](https://github.com/BioJulia/IntervalTrees.jl), respectively.
  - Benchmark the intersection with a target `UnitRange` from each of the representations of the reference ranges. Do this in two ways: `intersect`, which allocates the storage for the result, and `intersect!`, which modifies one of its arguments with the result.
  - Compute the coverage from the vector of intersections.
  - Apply the methods to the complete set of targets.

## Creating dictionaries of Vector{UnitRange}

  - A `UnitRange`, like `2:10`, includes the end points (accessed as `first` and `last`).

```{julia}
typeof(2:10)
```

```{julia}
length(2:10)
```

  - The positions in the `start` and `stop` columns in a `.bed` are not both included in the interval represented.  The positions correspond to the interval `start:(stop - 1)` as 0-based positions or `(start + 1):stop` in 1-based positions.
  - It doesn't matter which one we use as long as we are consistent.
  - We will start counting from 1, just like the [world's foremost expert on counting](https://twitter.com/CountVonCount) does.
  - We wrap this conversion in a utility function to help ensure consistency.

```{julia}
asrange(start, stop) = (start+one(start)):stop
```

::: {.callout-note}
`one(x)` is used instead of the literal `1` in `asrange` to preserve the integer type (see also `?oneunit`, which is slighly more general).

```{julia}
st = Int32(2314)
typeof(st + 1)       # type gets promoted to Int64
```

```{julia}
typeof(st + one(st)) # type not promoted
```

:::

::: {.callout-note}
This method definition uses the compact "one-liner" form.
:::

```{julia}
function datatable(fnroot::AbstractString)
  return DataFrame(Arrow.Table(joinpath(datadir, "$fnroot.arrow")))
end
function chromodict(df::DataFrame; sorted::Bool = false)
  T = eltype(df.start)
  vtype = Vector{UnitRange{T}}
  dict = Dict{Symbol,vtype}()
  for r in rowtable(sorted ? sort(df) : df)
    (; chromo, start, stop) = r
    push!(get!(dict, Symbol(chromo), vtype()), asrange(start, stop))
  end
  return dict
end
annorangevecs = chromodict(datatable("ex-anno"); sorted = true)
```

::: {.callout-note}
The call `get!(dict, Symbol(chromo), vtype())` in `chromodict` returns `dict[Symbol(chromo)]` or the default value, which is an empty `Vector{UnitRange{T}}`.
For the case of the default, it also installs that key/value pair in `dict`.
:::

  - Do the same for the `"ex-rna"` intervals (without sorting).

```{julia}
rnarangevecs = chromodict(datatable("ex-rna"))
```

  - We will use the intervals on chromsome 21 for our timing benchmarks.  The target for tests of intersection with a single target interval will be the last interval on chromosome 21 in "ex-rna.arrow".

```{julia}
rangevec21 = annorangevecs[:chr21]
rnarange21 = rnarangevecs[:chr21]
target = last(rnarange21)
```

# Intersecting reference ranges with a target

  - Create a method to intersect a target interval with a `Vector{UnitRange}` returning the intersections as another `Vector{UnitRange}`.

  - A common Julia programming idiom for such cases is to create two methods: one for `intersect!`, which modifies an argument that will hold the result, and one for `intersect`, which allocates the result then calls the `intersect!` method.
  - For the `intersect!` method we first `empty!` the result vector, which zeros the vector length but does not shrink the memory chunk allocated to the vector, then `push!` intersections onto it.  If there are many calls to an `intersect!` method like this only a few will cause memory allocations.
  - The elements of our vectors of reference intervals, like `rangevec21`, are sorted by their `first` element but the `last` elements do not have any special relationships.  The best we can do to determine all intersections is a sequential scan of the sorted vector of ranges with an early exit when `last(target) < first(vectorelement)`.

```{julia}
function intersect!(
  result::Vector{UnitRange{T}},
  target::AbstractUnitRange{<:Integer},
  refs::Vector{UnitRange{T}},
) where {T}
  empty!(result)
  target = eltype(refs)(target)  # coerce the type, if necessary
  lastt = last(target)
  for rng in refs
    isect = intersect(target, rng)
    !isempty(isect) && push!(result, isect)
    lastt < first(rng) && break
  end
  return result
end
function intersect(
  target::AbstractUnitRange{<:Integer},
  refs::Vector{UnitRange{T}},
) where {T}
  return intersect!(similar(refs, 0), target, refs)
end
savedresult = intersect(target, rangevec21)  # will use for comparisons
```

```{julia}
result = similar(rangevec21, 0)    # working storage
savedresult == intersect!(result, target, rangevec21)
```

# Dictionaries of RangeTrees and IntervalTrees

## RangeTrees

  - [RangeTrees.jl](https://github.com/dmbates/RangeTrees.jl) provides an implementation of [interval trees](https://en.wikipedia.org/wiki/Interval_tree) using the [augmented binary tree](https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree) formulation.

```{julia}
annorangetrees = Dict(k => RangeNode(v) for (k, v) in annorangevecs)
rangetree21 = annorangetrees[:chr21]
print_tree(rangetree21; maxdepth = 3)  # methods from AbstractTrees.jl
```

  - A `RangeTree` represents a balanced, binary tree of ranges, sorted by `first`, in a `Vector{RangeNode}`.  Each `RangeNode` contains a `UnitRange`, the indices of the left and right subtrees, and `maxlast`, which is the maximum value of the last element in the ranges of the subtree rooted at the node.

  - Evaluating and storing `maxlast` in the nodes allows for overlap searchs to be truncated at nodes for which `maxlast < first(target)`.  The sorting by `first` allows for skipping the right subtree whenever `last(target) < first(thisnode)` (as in the overlaps method for `Vector{UnitRange}`).
  - The root of `rangetree21` is the node at the median index of `rangevec21`, rounding the position up when the length of the vector of nodes is even.

```{julia}
length(rangevec21), midrange(eachindex(rangevec21))
```

```{julia}
rangetree21    # prints the root node of the tree
```

  - The `maxlast` value for the root node must be the maximum last position of any of the ranges.

```{julia}
maximum(last.(rangevec21))
```

  - It happens that this value is the same as the last position in the last range but that doesn't have to be the case.  The ranges are sorted by increasing first position, not by last position.

```{julia}
last(last(rangevec21))
```

  - `intersect` and `intersect!` methods are already defined in [RangeTrees.jl](https://github.com/dmbates/RangeTrees.jl).

  - Check that their results agree with the saved result.

```{julia}
savedresult == intersect(target, rangetree21)
```

```{julia}
savedresult == intersect!(result, target, rangetree21)
```

## IntervalTrees

  - Create a dictionary of `IntervalTree`s.  It is somewhat tedious to get the type of the result correct and we create a function to hide the details.

```{julia}
function toitrees(rngdict::Dict{S,Vector{UnitRange{T}}}) where {S,T}
  return Dict(
    k => IntervalTree{T,Interval{T}}(Interval.(v)) for (k, v) in rngdict
  )
end
annointvltrees = toitrees(annorangevecs)
intvltree21 = annointvltrees[:chr21]
show(intvltree21)
```

  - Creating an `intersect!` method is also tedious because the package has its own `Interval` data type and defines `intersect(itr::IntervalTree, (frst, lst))` to return an iterator of `Interval`s in the tree, not the intersection

```{julia}
Interval(target)
```

  - Create an `asrange` method for the inverse mapping

```{julia}
asrange(intvl::Interval) = first(intvl):last(intvl)
asrange(Interval(target)) == target  # check it
```

```{julia}
function intersect!(
  res::Vector{UnitRange{T}},
  target::AbstractUnitRange,
  refs::IntervalTree{T},
) where {T}
  empty!(res)
  firstt, lastt = first(target), last(target)
  for isect in intersect(refs, (firstt, lastt))
    push!(res, max(first(isect), firstt):min(last(isect), lastt))
  end
  return res
end
savedresult == intersect!(result, target, intvltree21) # check it
```

# Time for a shootout

### Vector{UnitRange}

```{julia}
@benchmark intersect!(res, tar, ref) setup =
  (res = result; tar = target; ref = rangevec21)
```

```{julia}
@benchmark intersect(tar, ref) setup = (tar = target; ref = rangevec21)
```

### RangeTree

```{julia}
@benchmark intersect!(res, tar, ref) setup =
  (res = result; tar = target; ref = rangetree21)
```

```{julia}
@benchmark intersect(tar, ref) setup = (tar = target; ref = rangetree21)
```

### IntervalTree

```{julia}
@benchmark intersect!(res, tar, ref) setup =
  (res = result; tar = target; ref = intvltree21)
```

  - In what follows we will use the `RangeTree` method for `intersect!` to obtain the intersections.

# Determining coverage

  - The `coverage` of a target by a set of reference intervals is the proportion of the base pairs in the target that intersect with one or more of the reference intervals.

  - We need to somehow count the number of elements in the union of the intervals returned from `intersect!`.
  - This could be done using the `union!` method for a [BitSet](https://docs.julialang.org/en/v1/base/collections/#Base.BitSet) but that approach has two problems: it is comparatively slow and, in Julia versions up to 1.8.0-rc1, it can be wrong.

::: {.callout-note}

  - While creating these notes we discovered a [bug](https://github.com/JuliaLang/julia/pull/45574) in the `union!` method for a `BitSet` and a `UnitRange`.

  - There was a [PR](https://github.com/JuliaLang/julia/pull/45578) to fix it the next morning.
  - Versions of Julia prior to 1.8.0-rc2 can (and probably will) return incorrect values of coverage.
  - Replacing `union!(bs, isect)` by `union!(bs, BitSet(isect))` avoids this "infelicity" at the expense of more memory usage and compute time.
    :::
  - There is a better method that takes advantage of the intersecting intervals being sorted by `first`
  - The idea is to "keep moving the goalposts". When evaluating the coverage count, add the length of the current reference interval's intersection with only the part to the right of what has already been covered.  The thing we know about the intersecting intervals is that each successive intervals's `first` position is greater than or equal to the `first` position of all the intervals preceding it.  That is, the intervals can't "move left" as we iterate through them.

```{julia}
function coveragecount(
  target::AbstractUnitRange,
  isects::Vector{UnitRange{T}},
) where {T}
  goalposts = target
  rightpost = last(goalposts)
  coverage = 0
  for isect in isects
    coverage += length(intersect(goalposts, isect))
    goalposts = (last(isect)+one(T)):rightpost
  end
  return coverage
end
coveragecount(target, savedresult)
```

# Iterating over a collection of targets

```{julia}
function overlaps(targets::Vector{UnitRange{T}}, refs::RangeNode{T}) where {T}
  ntargets = length(targets)
  nover = sizehint!(Int[], ntargets)
  covcount = sizehint!(T[], ntargets)
  result = sizehint!(UnitRange{T}[], Int(round(sqrt(ntargets))))
  for tar in targets
    push!(nover, length(intersect!(result, tar, refs)))
    push!(covcount, coveragecount(tar, result))
  end
  DataFrame(targets = targets, nover = nover, covcount = covcount)
end
overlaps(rnarange21, rangetree21)
```

```{julia}
@benchmark overlaps(targets, refs) setup =
  (targets = rnarange21; refs = rangetree21)
```

# The whole shootin' match

  - The computations on different chromosome are independent of each other and can be assigned to different threads when Julia is started with multiple threads.

```{julia}
function overlaps(
  targets::Dict{Symbol,Vector{UnitRange{T}}},
  refdict::Dict{Symbol,RangeNode{T}},
) where {T}
  value = Dict{Symbol,DataFrame}()
  @sync for k in intersect(keys(targets), keys(refdict))
    Threads.@spawn value[k] = overlaps(targets[k], refdict[k])
  end
  return value
end
bigresult = overlaps(rnarangevecs, annorangetrees);
bigresult[:chrY]
```

```{julia}
@benchmark overlaps(targets, refs) setup =
  (targets = rnarangevecs; refs = annorangetrees)
```

# Conclusions

  - The ability to work in the REPL (or VS Code or Jupyter notebooks) encourages iterative refinement of algorithms.
  - "Trust but verify" - when making a change or introducing new methods it helps to have results from previous methods for comparison.  In general, continuous integration (CI) testing is straightforward for Julia packages and is strongly encouraged.
  - There are many tools for benchmarking function execution or storage allocation, allowing a developer to concentrate on where the "real problem" is.
  - In certain cases, enhancements like multi-threading can be achieved with very little effort.

# Version information

```{julia}
versioninfo()
```
